---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/3/26 17:09
---
---@class Mail
local mail = class(nil, "Mail")

function mail:ctor(mail)
    self:CopyFrom(mail)
end

function mail:SetReadState(flag)
    self.beRead = flag
end
function mail:GetReadState()
    return self.beRead
end
--region time

function mail:GetTotalTime()
    return self.endTime/1000 - self.startTime/1000
end

function mail:OutOfTime()
    return self.endTime/1000 - TimeUtil.ServerTime() <0
end

-->0 <1    day = 1
-->1 day = 1+1
function mail:GetReaminTime_str()
    local lastTime = self.endTime/1000 - TimeUtil.ServerTime()
    local lastDay = self:get_day(lastTime)
    if lastDay > 1 then
        return Runtime.Translate('ui_mail_remain_time_gt_1',{day = tostring(lastDay)})
    else
        if lastDay >0 then
            return Runtime.Translate('ui_mail_remain_time_lt_1',{day = '1'})
        else
            return Runtime.Translate('ui_mail_out_of_date')
        end
    end
end

function mail:GetStartTime_str()
    local duration = TimeUtil.ServerTime() - self.startTime/1000
    --过去的时间小于0？ 怎么可能呢？肯定出错了
    if duration < 0 then
        return Runtime.Translate('ui_mail_duration_time_lt_1',{day = '1'})
    else
        local durationDay = self:get_day(duration)-1
        if durationDay < 1 then
            --过去的时间小于一天，显示过去了几个小时
            return Runtime.Translate('ui_mail_duration_time_lt_1',{day = tostring(self:get_hour(duration))})
        else
            --大于一天，显示过去了几天
            return Runtime.Translate('ui_mail_duration_time_gt_1',{day = tostring(durationDay)})
        end
    end
end

function mail:get_day(ts)
    return math.ceil(ts / 60 / 60 / 24)
end

function mail:get_hour(ts)
    return math.ceil(ts / 60 / 60)
end

function mail:CopyFrom(mail)

    self.id = mail.id
    self.type = mail.type
    self.startTime = mail.startTime
    self.endTime = mail.endTime
    self.title = mail.label
    self.content = mail.content
    self.picUrl = mail.picture

    self.attachment = mail.attachment
    self.rewards = {}
    for i, v in pairs(mail.attachment or {}) do
        --table.insert(self.rewards, { ItemId = v[1], Amount = v[2] })
        table.insert(self.rewards, { ItemId = v.itemTemplateId, Amount = v.count })
    end
    self.rawRewards = mail.attachment or {}

    self.beRead = mail.read

    if mail.reward then
        self.hasGift = false
    else
        self.hasGift = #self.attachment>0
    end

    self.startTimeParsed =TimeUtil.GetTimeString(self.startTime//1000)

end
--endregion
return mail