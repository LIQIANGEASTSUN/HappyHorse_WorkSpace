// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapCliRpc.proto

#ifndef PROTOBUF_MapCliRpc_2eproto__INCLUDED
#define PROTOBUF_MapCliRpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PublicStruct.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MapCliRpc_2eproto();
void protobuf_AssignDesc_MapCliRpc_2eproto();
void protobuf_ShutdownFile_MapCliRpc_2eproto();

class MapSceneData;
class MapBasePlaymodeData;
class MapTeamData;
class MapSprayData;
class MapPvpData;
class MapPRS;
class MapCameraData;
class MapLiftingConfig;
class MapPositionGraph;

// ===================================================================

class MapSceneData : public ::google::protobuf::Message {
 public:
  MapSceneData();
  virtual ~MapSceneData();

  MapSceneData(const MapSceneData& from);

  inline MapSceneData& operator=(const MapSceneData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapSceneData& default_instance();

  void Swap(MapSceneData* other);

  // implements Message ----------------------------------------------

  MapSceneData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapSceneData& from);
  void MergeFrom(const MapSceneData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 MapId = 1 [default = -1];
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional string SceneName = 2;
  inline bool has_scenename() const;
  inline void clear_scenename();
  static const int kSceneNameFieldNumber = 2;
  inline const ::std::string& scenename() const;
  inline void set_scenename(const ::std::string& value);
  inline void set_scenename(const char* value);
  inline void set_scenename(const char* value, size_t size);
  inline ::std::string* mutable_scenename();
  inline ::std::string* release_scenename();
  inline void set_allocated_scenename(::std::string* scenename);

  // optional string SceneFileName = 20;
  inline bool has_scenefilename() const;
  inline void clear_scenefilename();
  static const int kSceneFileNameFieldNumber = 20;
  inline const ::std::string& scenefilename() const;
  inline void set_scenefilename(const ::std::string& value);
  inline void set_scenefilename(const char* value);
  inline void set_scenefilename(const char* value, size_t size);
  inline ::std::string* mutable_scenefilename();
  inline ::std::string* release_scenefilename();
  inline void set_allocated_scenefilename(::std::string* scenefilename);

  // optional string ClientSceneName = 19;
  inline bool has_clientscenename() const;
  inline void clear_clientscenename();
  static const int kClientSceneNameFieldNumber = 19;
  inline const ::std::string& clientscenename() const;
  inline void set_clientscenename(const ::std::string& value);
  inline void set_clientscenename(const char* value);
  inline void set_clientscenename(const char* value, size_t size);
  inline ::std::string* mutable_clientscenename();
  inline ::std::string* release_clientscenename();
  inline void set_allocated_clientscenename(::std::string* clientscenename);

  // optional string MapSimplify = 3;
  inline bool has_mapsimplify() const;
  inline void clear_mapsimplify();
  static const int kMapSimplifyFieldNumber = 3;
  inline const ::std::string& mapsimplify() const;
  inline void set_mapsimplify(const ::std::string& value);
  inline void set_mapsimplify(const char* value);
  inline void set_mapsimplify(const char* value, size_t size);
  inline ::std::string* mutable_mapsimplify();
  inline ::std::string* release_mapsimplify();
  inline void set_allocated_mapsimplify(::std::string* mapsimplify);

  // optional sint32 MapSimplifyRotate1 = 4 [default = -1];
  inline bool has_mapsimplifyrotate1() const;
  inline void clear_mapsimplifyrotate1();
  static const int kMapSimplifyRotate1FieldNumber = 4;
  inline ::google::protobuf::int32 mapsimplifyrotate1() const;
  inline void set_mapsimplifyrotate1(::google::protobuf::int32 value);

  // optional sint32 MapSimplifyRotate2 = 5 [default = -1];
  inline bool has_mapsimplifyrotate2() const;
  inline void clear_mapsimplifyrotate2();
  static const int kMapSimplifyRotate2FieldNumber = 5;
  inline ::google::protobuf::int32 mapsimplifyrotate2() const;
  inline void set_mapsimplifyrotate2(::google::protobuf::int32 value);

  // optional float MapPosX = 6 [default = -1];
  inline bool has_mapposx() const;
  inline void clear_mapposx();
  static const int kMapPosXFieldNumber = 6;
  inline float mapposx() const;
  inline void set_mapposx(float value);

  // optional float MapPosY = 7 [default = -1];
  inline bool has_mapposy() const;
  inline void clear_mapposy();
  static const int kMapPosYFieldNumber = 7;
  inline float mapposy() const;
  inline void set_mapposy(float value);

  // optional float MapPivotX = 8 [default = -1];
  inline bool has_mappivotx() const;
  inline void clear_mappivotx();
  static const int kMapPivotXFieldNumber = 8;
  inline float mappivotx() const;
  inline void set_mappivotx(float value);

  // optional float MapPivotY = 9 [default = -1];
  inline bool has_mappivoty() const;
  inline void clear_mappivoty();
  static const int kMapPivotYFieldNumber = 9;
  inline float mappivoty() const;
  inline void set_mappivoty(float value);

  // optional float UIWorldRatio = 10 [default = -1];
  inline bool has_uiworldratio() const;
  inline void clear_uiworldratio();
  static const int kUIWorldRatioFieldNumber = 10;
  inline float uiworldratio() const;
  inline void set_uiworldratio(float value);

  // optional string MapDetailed = 11;
  inline bool has_mapdetailed() const;
  inline void clear_mapdetailed();
  static const int kMapDetailedFieldNumber = 11;
  inline const ::std::string& mapdetailed() const;
  inline void set_mapdetailed(const ::std::string& value);
  inline void set_mapdetailed(const char* value);
  inline void set_mapdetailed(const char* value, size_t size);
  inline ::std::string* mutable_mapdetailed();
  inline ::std::string* release_mapdetailed();
  inline void set_allocated_mapdetailed(::std::string* mapdetailed);

  // optional sint32 MapDetailedRotate1 = 12 [default = -1];
  inline bool has_mapdetailedrotate1() const;
  inline void clear_mapdetailedrotate1();
  static const int kMapDetailedRotate1FieldNumber = 12;
  inline ::google::protobuf::int32 mapdetailedrotate1() const;
  inline void set_mapdetailedrotate1(::google::protobuf::int32 value);

  // optional sint32 MapDetailedRotate2 = 13 [default = -1];
  inline bool has_mapdetailedrotate2() const;
  inline void clear_mapdetailedrotate2();
  static const int kMapDetailedRotate2FieldNumber = 13;
  inline ::google::protobuf::int32 mapdetailedrotate2() const;
  inline void set_mapdetailedrotate2(::google::protobuf::int32 value);

  // optional float ServerUIRadio = 14 [default = -1];
  inline bool has_serveruiradio() const;
  inline void clear_serveruiradio();
  static const int kServerUIRadioFieldNumber = 14;
  inline float serveruiradio() const;
  inline void set_serveruiradio(float value);

  // optional .MapPvpData Pvp = 15;
  inline bool has_pvp() const;
  inline void clear_pvp();
  static const int kPvpFieldNumber = 15;
  inline const ::MapPvpData& pvp() const;
  inline ::MapPvpData* mutable_pvp();
  inline ::MapPvpData* release_pvp();
  inline void set_allocated_pvp(::MapPvpData* pvp);

  // repeated .MapSprayData Sprays = 16;
  inline int sprays_size() const;
  inline void clear_sprays();
  static const int kSpraysFieldNumber = 16;
  inline const ::MapSprayData& sprays(int index) const;
  inline ::MapSprayData* mutable_sprays(int index);
  inline ::MapSprayData* add_sprays();
  inline const ::google::protobuf::RepeatedPtrField< ::MapSprayData >&
      sprays() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapSprayData >*
      mutable_sprays();

  // repeated .MapTeamData Teams = 17;
  inline int teams_size() const;
  inline void clear_teams();
  static const int kTeamsFieldNumber = 17;
  inline const ::MapTeamData& teams(int index) const;
  inline ::MapTeamData* mutable_teams(int index);
  inline ::MapTeamData* add_teams();
  inline const ::google::protobuf::RepeatedPtrField< ::MapTeamData >&
      teams() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapTeamData >*
      mutable_teams();

  // optional string LowModel = 18;
  inline bool has_lowmodel() const;
  inline void clear_lowmodel();
  static const int kLowModelFieldNumber = 18;
  inline const ::std::string& lowmodel() const;
  inline void set_lowmodel(const ::std::string& value);
  inline void set_lowmodel(const char* value);
  inline void set_lowmodel(const char* value, size_t size);
  inline ::std::string* mutable_lowmodel();
  inline ::std::string* release_lowmodel();
  inline void set_allocated_lowmodel(::std::string* lowmodel);

  // optional float AlphaSpeed = 21 [default = -1];
  inline bool has_alphaspeed() const;
  inline void clear_alphaspeed();
  static const int kAlphaSpeedFieldNumber = 21;
  inline float alphaspeed() const;
  inline void set_alphaspeed(float value);

  // optional float TransferRadius = 22 [default = -1];
  inline bool has_transferradius() const;
  inline void clear_transferradius();
  static const int kTransferRadiusFieldNumber = 22;
  inline float transferradius() const;
  inline void set_transferradius(float value);

  // optional string MapEffectAura = 23;
  inline bool has_mapeffectaura() const;
  inline void clear_mapeffectaura();
  static const int kMapEffectAuraFieldNumber = 23;
  inline const ::std::string& mapeffectaura() const;
  inline void set_mapeffectaura(const ::std::string& value);
  inline void set_mapeffectaura(const char* value);
  inline void set_mapeffectaura(const char* value, size_t size);
  inline ::std::string* mutable_mapeffectaura();
  inline ::std::string* release_mapeffectaura();
  inline void set_allocated_mapeffectaura(::std::string* mapeffectaura);

  // optional string MapEffecttransfer = 24;
  inline bool has_mapeffecttransfer() const;
  inline void clear_mapeffecttransfer();
  static const int kMapEffecttransferFieldNumber = 24;
  inline const ::std::string& mapeffecttransfer() const;
  inline void set_mapeffecttransfer(const ::std::string& value);
  inline void set_mapeffecttransfer(const char* value);
  inline void set_mapeffecttransfer(const char* value, size_t size);
  inline ::std::string* mutable_mapeffecttransfer();
  inline ::std::string* release_mapeffecttransfer();
  inline void set_allocated_mapeffecttransfer(::std::string* mapeffecttransfer);

  // optional string MapEffectArrive = 25;
  inline bool has_mapeffectarrive() const;
  inline void clear_mapeffectarrive();
  static const int kMapEffectArriveFieldNumber = 25;
  inline const ::std::string& mapeffectarrive() const;
  inline void set_mapeffectarrive(const ::std::string& value);
  inline void set_mapeffectarrive(const char* value);
  inline void set_mapeffectarrive(const char* value, size_t size);
  inline ::std::string* mutable_mapeffectarrive();
  inline ::std::string* release_mapeffectarrive();
  inline void set_allocated_mapeffectarrive(::std::string* mapeffectarrive);

  // repeated .MapPositionGraph PathGraphs = 26;
  inline int pathgraphs_size() const;
  inline void clear_pathgraphs();
  static const int kPathGraphsFieldNumber = 26;
  inline const ::MapPositionGraph& pathgraphs(int index) const;
  inline ::MapPositionGraph* mutable_pathgraphs(int index);
  inline ::MapPositionGraph* add_pathgraphs();
  inline const ::google::protobuf::RepeatedPtrField< ::MapPositionGraph >&
      pathgraphs() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapPositionGraph >*
      mutable_pathgraphs();

  // @@protoc_insertion_point(class_scope:MapSceneData)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_scenename();
  inline void clear_has_scenename();
  inline void set_has_scenefilename();
  inline void clear_has_scenefilename();
  inline void set_has_clientscenename();
  inline void clear_has_clientscenename();
  inline void set_has_mapsimplify();
  inline void clear_has_mapsimplify();
  inline void set_has_mapsimplifyrotate1();
  inline void clear_has_mapsimplifyrotate1();
  inline void set_has_mapsimplifyrotate2();
  inline void clear_has_mapsimplifyrotate2();
  inline void set_has_mapposx();
  inline void clear_has_mapposx();
  inline void set_has_mapposy();
  inline void clear_has_mapposy();
  inline void set_has_mappivotx();
  inline void clear_has_mappivotx();
  inline void set_has_mappivoty();
  inline void clear_has_mappivoty();
  inline void set_has_uiworldratio();
  inline void clear_has_uiworldratio();
  inline void set_has_mapdetailed();
  inline void clear_has_mapdetailed();
  inline void set_has_mapdetailedrotate1();
  inline void clear_has_mapdetailedrotate1();
  inline void set_has_mapdetailedrotate2();
  inline void clear_has_mapdetailedrotate2();
  inline void set_has_serveruiradio();
  inline void clear_has_serveruiradio();
  inline void set_has_pvp();
  inline void clear_has_pvp();
  inline void set_has_lowmodel();
  inline void clear_has_lowmodel();
  inline void set_has_alphaspeed();
  inline void clear_has_alphaspeed();
  inline void set_has_transferradius();
  inline void clear_has_transferradius();
  inline void set_has_mapeffectaura();
  inline void clear_has_mapeffectaura();
  inline void set_has_mapeffecttransfer();
  inline void clear_has_mapeffecttransfer();
  inline void set_has_mapeffectarrive();
  inline void clear_has_mapeffectarrive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* scenename_;
  ::std::string* scenefilename_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 mapsimplifyrotate1_;
  ::std::string* clientscenename_;
  ::std::string* mapsimplify_;
  ::google::protobuf::int32 mapsimplifyrotate2_;
  float mapposx_;
  float mapposy_;
  float mappivotx_;
  float mappivoty_;
  float uiworldratio_;
  ::std::string* mapdetailed_;
  ::google::protobuf::int32 mapdetailedrotate1_;
  ::google::protobuf::int32 mapdetailedrotate2_;
  ::MapPvpData* pvp_;
  ::google::protobuf::RepeatedPtrField< ::MapSprayData > sprays_;
  float serveruiradio_;
  float alphaspeed_;
  ::google::protobuf::RepeatedPtrField< ::MapTeamData > teams_;
  ::std::string* lowmodel_;
  ::std::string* mapeffectaura_;
  ::std::string* mapeffecttransfer_;
  ::std::string* mapeffectarrive_;
  ::google::protobuf::RepeatedPtrField< ::MapPositionGraph > pathgraphs_;
  float transferradius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapSceneData* default_instance_;
};
// -------------------------------------------------------------------

class MapBasePlaymodeData : public ::google::protobuf::Message {
 public:
  MapBasePlaymodeData();
  virtual ~MapBasePlaymodeData();

  MapBasePlaymodeData(const MapBasePlaymodeData& from);

  inline MapBasePlaymodeData& operator=(const MapBasePlaymodeData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapBasePlaymodeData& default_instance();

  void Swap(MapBasePlaymodeData* other);

  // implements Message ----------------------------------------------

  MapBasePlaymodeData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapBasePlaymodeData& from);
  void MergeFrom(const MapBasePlaymodeData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Type = 5 [default = -1];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string Desc1 = 1;
  inline bool has_desc1() const;
  inline void clear_desc1();
  static const int kDesc1FieldNumber = 1;
  inline const ::std::string& desc1() const;
  inline void set_desc1(const ::std::string& value);
  inline void set_desc1(const char* value);
  inline void set_desc1(const char* value, size_t size);
  inline ::std::string* mutable_desc1();
  inline ::std::string* release_desc1();
  inline void set_allocated_desc1(::std::string* desc1);

  // optional string Desc2 = 2;
  inline bool has_desc2() const;
  inline void clear_desc2();
  static const int kDesc2FieldNumber = 2;
  inline const ::std::string& desc2() const;
  inline void set_desc2(const ::std::string& value);
  inline void set_desc2(const char* value);
  inline void set_desc2(const char* value, size_t size);
  inline ::std::string* mutable_desc2();
  inline ::std::string* release_desc2();
  inline void set_allocated_desc2(::std::string* desc2);

  // optional string ModeName = 3;
  inline bool has_modename() const;
  inline void clear_modename();
  static const int kModeNameFieldNumber = 3;
  inline const ::std::string& modename() const;
  inline void set_modename(const ::std::string& value);
  inline void set_modename(const char* value);
  inline void set_modename(const char* value, size_t size);
  inline ::std::string* mutable_modename();
  inline ::std::string* release_modename();
  inline void set_allocated_modename(::std::string* modename);

  // optional string Uibg = 4;
  inline bool has_uibg() const;
  inline void clear_uibg();
  static const int kUibgFieldNumber = 4;
  inline const ::std::string& uibg() const;
  inline void set_uibg(const ::std::string& value);
  inline void set_uibg(const char* value);
  inline void set_uibg(const char* value, size_t size);
  inline ::std::string* mutable_uibg();
  inline ::std::string* release_uibg();
  inline void set_allocated_uibg(::std::string* uibg);

  // repeated .MapCameraData MainCameras = 6;
  inline int maincameras_size() const;
  inline void clear_maincameras();
  static const int kMainCamerasFieldNumber = 6;
  inline const ::MapCameraData& maincameras(int index) const;
  inline ::MapCameraData* mutable_maincameras(int index);
  inline ::MapCameraData* add_maincameras();
  inline const ::google::protobuf::RepeatedPtrField< ::MapCameraData >&
      maincameras() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapCameraData >*
      mutable_maincameras();

  // repeated .MapCameraData SlaveCameras = 7;
  inline int slavecameras_size() const;
  inline void clear_slavecameras();
  static const int kSlaveCamerasFieldNumber = 7;
  inline const ::MapCameraData& slavecameras(int index) const;
  inline ::MapCameraData* mutable_slavecameras(int index);
  inline ::MapCameraData* add_slavecameras();
  inline const ::google::protobuf::RepeatedPtrField< ::MapCameraData >&
      slavecameras() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapCameraData >*
      mutable_slavecameras();

  // repeated .MapLiftingConfig Liftings = 8;
  inline int liftings_size() const;
  inline void clear_liftings();
  static const int kLiftingsFieldNumber = 8;
  inline const ::MapLiftingConfig& liftings(int index) const;
  inline ::MapLiftingConfig* mutable_liftings(int index);
  inline ::MapLiftingConfig* add_liftings();
  inline const ::google::protobuf::RepeatedPtrField< ::MapLiftingConfig >&
      liftings() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapLiftingConfig >*
      mutable_liftings();

  // optional string CharacterAnim = 9;
  inline bool has_characteranim() const;
  inline void clear_characteranim();
  static const int kCharacterAnimFieldNumber = 9;
  inline const ::std::string& characteranim() const;
  inline void set_characteranim(const ::std::string& value);
  inline void set_characteranim(const char* value);
  inline void set_characteranim(const char* value, size_t size);
  inline ::std::string* mutable_characteranim();
  inline ::std::string* release_characteranim();
  inline void set_allocated_characteranim(::std::string* characteranim);

  // optional string ReadyFile = 10;
  inline bool has_readyfile() const;
  inline void clear_readyfile();
  static const int kReadyFileFieldNumber = 10;
  inline const ::std::string& readyfile() const;
  inline void set_readyfile(const ::std::string& value);
  inline void set_readyfile(const char* value);
  inline void set_readyfile(const char* value, size_t size);
  inline ::std::string* mutable_readyfile();
  inline ::std::string* release_readyfile();
  inline void set_allocated_readyfile(::std::string* readyfile);

  // optional float ReadyTime = 11 [default = -1];
  inline bool has_readytime() const;
  inline void clear_readytime();
  static const int kReadyTimeFieldNumber = 11;
  inline float readytime() const;
  inline void set_readytime(float value);

  // optional float ControlTime = 12 [default = -1];
  inline bool has_controltime() const;
  inline void clear_controltime();
  static const int kControlTimeFieldNumber = 12;
  inline float controltime() const;
  inline void set_controltime(float value);

  // optional float ChangePriTime = 13 [default = -1];
  inline bool has_changepritime() const;
  inline void clear_changepritime();
  static const int kChangePriTimeFieldNumber = 13;
  inline float changepritime() const;
  inline void set_changepritime(float value);

  // @@protoc_insertion_point(class_scope:MapBasePlaymodeData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_desc1();
  inline void clear_has_desc1();
  inline void set_has_desc2();
  inline void clear_has_desc2();
  inline void set_has_modename();
  inline void clear_has_modename();
  inline void set_has_uibg();
  inline void clear_has_uibg();
  inline void set_has_characteranim();
  inline void clear_has_characteranim();
  inline void set_has_readyfile();
  inline void clear_has_readyfile();
  inline void set_has_readytime();
  inline void clear_has_readytime();
  inline void set_has_controltime();
  inline void clear_has_controltime();
  inline void set_has_changepritime();
  inline void clear_has_changepritime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* desc1_;
  ::std::string* desc2_;
  ::std::string* modename_;
  ::std::string* uibg_;
  ::google::protobuf::RepeatedPtrField< ::MapCameraData > maincameras_;
  ::google::protobuf::int32 type_;
  float readytime_;
  ::google::protobuf::RepeatedPtrField< ::MapCameraData > slavecameras_;
  ::google::protobuf::RepeatedPtrField< ::MapLiftingConfig > liftings_;
  ::std::string* characteranim_;
  ::std::string* readyfile_;
  float controltime_;
  float changepritime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapBasePlaymodeData* default_instance_;
};
// -------------------------------------------------------------------

class MapTeamData : public ::google::protobuf::Message {
 public:
  MapTeamData();
  virtual ~MapTeamData();

  MapTeamData(const MapTeamData& from);

  inline MapTeamData& operator=(const MapTeamData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapTeamData& default_instance();

  void Swap(MapTeamData* other);

  // implements Message ----------------------------------------------

  MapTeamData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapTeamData& from);
  void MergeFrom(const MapTeamData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Guard = 1;
  inline bool has_guard() const;
  inline void clear_guard();
  static const int kGuardFieldNumber = 1;
  inline const ::std::string& guard() const;
  inline void set_guard(const ::std::string& value);
  inline void set_guard(const char* value);
  inline void set_guard(const char* value, size_t size);
  inline ::std::string* mutable_guard();
  inline ::std::string* release_guard();
  inline void set_allocated_guard(::std::string* guard);

  // optional string Pedestal = 2;
  inline bool has_pedestal() const;
  inline void clear_pedestal();
  static const int kPedestalFieldNumber = 2;
  inline const ::std::string& pedestal() const;
  inline void set_pedestal(const ::std::string& value);
  inline void set_pedestal(const char* value);
  inline void set_pedestal(const char* value, size_t size);
  inline ::std::string* mutable_pedestal();
  inline ::std::string* release_pedestal();
  inline void set_allocated_pedestal(::std::string* pedestal);

  // repeated .MapPRS SpawnPoints = 3;
  inline int spawnpoints_size() const;
  inline void clear_spawnpoints();
  static const int kSpawnPointsFieldNumber = 3;
  inline const ::MapPRS& spawnpoints(int index) const;
  inline ::MapPRS* mutable_spawnpoints(int index);
  inline ::MapPRS* add_spawnpoints();
  inline const ::google::protobuf::RepeatedPtrField< ::MapPRS >&
      spawnpoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapPRS >*
      mutable_spawnpoints();

  // optional string Lifting = 4;
  inline bool has_lifting() const;
  inline void clear_lifting();
  static const int kLiftingFieldNumber = 4;
  inline const ::std::string& lifting() const;
  inline void set_lifting(const ::std::string& value);
  inline void set_lifting(const char* value);
  inline void set_lifting(const char* value, size_t size);
  inline ::std::string* mutable_lifting();
  inline ::std::string* release_lifting();
  inline void set_allocated_lifting(::std::string* lifting);

  // optional sint32 Id = 5 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .Color4PB Color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::Color4PB& color() const;
  inline ::Color4PB* mutable_color();
  inline ::Color4PB* release_color();
  inline void set_allocated_color(::Color4PB* color);

  // optional .Vector3PB PedestalPosition = 7;
  inline bool has_pedestalposition() const;
  inline void clear_pedestalposition();
  static const int kPedestalPositionFieldNumber = 7;
  inline const ::Vector3PB& pedestalposition() const;
  inline ::Vector3PB* mutable_pedestalposition();
  inline ::Vector3PB* release_pedestalposition();
  inline void set_allocated_pedestalposition(::Vector3PB* pedestalposition);

  // @@protoc_insertion_point(class_scope:MapTeamData)
 private:
  inline void set_has_guard();
  inline void clear_has_guard();
  inline void set_has_pedestal();
  inline void clear_has_pedestal();
  inline void set_has_lifting();
  inline void clear_has_lifting();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_pedestalposition();
  inline void clear_has_pedestalposition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* guard_;
  ::std::string* pedestal_;
  ::google::protobuf::RepeatedPtrField< ::MapPRS > spawnpoints_;
  ::std::string* lifting_;
  ::Color4PB* color_;
  ::Vector3PB* pedestalposition_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapTeamData* default_instance_;
};
// -------------------------------------------------------------------

class MapSprayData : public ::google::protobuf::Message {
 public:
  MapSprayData();
  virtual ~MapSprayData();

  MapSprayData(const MapSprayData& from);

  inline MapSprayData& operator=(const MapSprayData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapSprayData& default_instance();

  void Swap(MapSprayData* other);

  // implements Message ----------------------------------------------

  MapSprayData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapSprayData& from);
  void MergeFrom(const MapSprayData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .Vector3PB Position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::Vector3PB& position() const;
  inline ::Vector3PB* mutable_position();
  inline ::Vector3PB* release_position();
  inline void set_allocated_position(::Vector3PB* position);

  // optional sint32 Dpi = 3 [default = -1];
  inline bool has_dpi() const;
  inline void clear_dpi();
  static const int kDpiFieldNumber = 3;
  inline ::google::protobuf::int32 dpi() const;
  inline void set_dpi(::google::protobuf::int32 value);

  // optional float Coefficient = 4 [default = -1];
  inline bool has_coefficient() const;
  inline void clear_coefficient();
  static const int kCoefficientFieldNumber = 4;
  inline float coefficient() const;
  inline void set_coefficient(float value);

  // @@protoc_insertion_point(class_scope:MapSprayData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_dpi();
  inline void clear_has_dpi();
  inline void set_has_coefficient();
  inline void clear_has_coefficient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::Vector3PB* position_;
  ::google::protobuf::int32 dpi_;
  float coefficient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapSprayData* default_instance_;
};
// -------------------------------------------------------------------

class MapPvpData : public ::google::protobuf::Message {
 public:
  MapPvpData();
  virtual ~MapPvpData();

  MapPvpData(const MapPvpData& from);

  inline MapPvpData& operator=(const MapPvpData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPvpData& default_instance();

  void Swap(MapPvpData* other);

  // implements Message ----------------------------------------------

  MapPvpData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPvpData& from);
  void MergeFrom(const MapPvpData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MapBasePlaymodeData BaseData = 1;
  inline bool has_basedata() const;
  inline void clear_basedata();
  static const int kBaseDataFieldNumber = 1;
  inline const ::MapBasePlaymodeData& basedata() const;
  inline ::MapBasePlaymodeData* mutable_basedata();
  inline ::MapBasePlaymodeData* release_basedata();
  inline void set_allocated_basedata(::MapBasePlaymodeData* basedata);

  // optional string AddHere = 2;
  inline bool has_addhere() const;
  inline void clear_addhere();
  static const int kAddHereFieldNumber = 2;
  inline const ::std::string& addhere() const;
  inline void set_addhere(const ::std::string& value);
  inline void set_addhere(const char* value);
  inline void set_addhere(const char* value, size_t size);
  inline ::std::string* mutable_addhere();
  inline ::std::string* release_addhere();
  inline void set_allocated_addhere(::std::string* addhere);

  // @@protoc_insertion_point(class_scope:MapPvpData)
 private:
  inline void set_has_basedata();
  inline void clear_has_basedata();
  inline void set_has_addhere();
  inline void clear_has_addhere();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MapBasePlaymodeData* basedata_;
  ::std::string* addhere_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapPvpData* default_instance_;
};
// -------------------------------------------------------------------

class MapPRS : public ::google::protobuf::Message {
 public:
  MapPRS();
  virtual ~MapPRS();

  MapPRS(const MapPRS& from);

  inline MapPRS& operator=(const MapPRS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPRS& default_instance();

  void Swap(MapPRS* other);

  // implements Message ----------------------------------------------

  MapPRS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPRS& from);
  void MergeFrom(const MapPRS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Vector3PB Position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::Vector3PB& position() const;
  inline ::Vector3PB* mutable_position();
  inline ::Vector3PB* release_position();
  inline void set_allocated_position(::Vector3PB* position);

  // optional .Vector3PB EularRotation = 2;
  inline bool has_eularrotation() const;
  inline void clear_eularrotation();
  static const int kEularRotationFieldNumber = 2;
  inline const ::Vector3PB& eularrotation() const;
  inline ::Vector3PB* mutable_eularrotation();
  inline ::Vector3PB* release_eularrotation();
  inline void set_allocated_eularrotation(::Vector3PB* eularrotation);

  // optional .Vector3PB Scale = 3;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 3;
  inline const ::Vector3PB& scale() const;
  inline ::Vector3PB* mutable_scale();
  inline ::Vector3PB* release_scale();
  inline void set_allocated_scale(::Vector3PB* scale);

  // @@protoc_insertion_point(class_scope:MapPRS)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_eularrotation();
  inline void clear_has_eularrotation();
  inline void set_has_scale();
  inline void clear_has_scale();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3PB* position_;
  ::Vector3PB* eularrotation_;
  ::Vector3PB* scale_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapPRS* default_instance_;
};
// -------------------------------------------------------------------

class MapCameraData : public ::google::protobuf::Message {
 public:
  MapCameraData();
  virtual ~MapCameraData();

  MapCameraData(const MapCameraData& from);

  inline MapCameraData& operator=(const MapCameraData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapCameraData& default_instance();

  void Swap(MapCameraData* other);

  // implements Message ----------------------------------------------

  MapCameraData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapCameraData& from);
  void MergeFrom(const MapCameraData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional float StartTime = 2 [default = -1];
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  inline float starttime() const;
  inline void set_starttime(float value);

  // optional float EndTime = 3 [default = -1];
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 3;
  inline float endtime() const;
  inline void set_endtime(float value);

  // @@protoc_insertion_point(class_scope:MapCameraData)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  float starttime_;
  float endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapCameraData* default_instance_;
};
// -------------------------------------------------------------------

class MapLiftingConfig : public ::google::protobuf::Message {
 public:
  MapLiftingConfig();
  virtual ~MapLiftingConfig();

  MapLiftingConfig(const MapLiftingConfig& from);

  inline MapLiftingConfig& operator=(const MapLiftingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapLiftingConfig& default_instance();

  void Swap(MapLiftingConfig* other);

  // implements Message ----------------------------------------------

  MapLiftingConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapLiftingConfig& from);
  void MergeFrom(const MapLiftingConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float StartTime = 1 [default = -1];
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline float starttime() const;
  inline void set_starttime(float value);

  // optional float Speed = 2 [default = -1];
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 2;
  inline float speed() const;
  inline void set_speed(float value);

  // @@protoc_insertion_point(class_scope:MapLiftingConfig)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float starttime_;
  float speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapLiftingConfig* default_instance_;
};
// -------------------------------------------------------------------

class MapPositionGraph : public ::google::protobuf::Message {
 public:
  MapPositionGraph();
  virtual ~MapPositionGraph();

  MapPositionGraph(const MapPositionGraph& from);

  inline MapPositionGraph& operator=(const MapPositionGraph& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPositionGraph& default_instance();

  void Swap(MapPositionGraph* other);

  // implements Message ----------------------------------------------

  MapPositionGraph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapPositionGraph& from);
  void MergeFrom(const MapPositionGraph& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Id = 1 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .Vector3PB Vertices = 2;
  inline int vertices_size() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 2;
  inline const ::Vector3PB& vertices(int index) const;
  inline ::Vector3PB* mutable_vertices(int index);
  inline ::Vector3PB* add_vertices();
  inline const ::google::protobuf::RepeatedPtrField< ::Vector3PB >&
      vertices() const;
  inline ::google::protobuf::RepeatedPtrField< ::Vector3PB >*
      mutable_vertices();

  // repeated .Vector2IntPB Edges = 3;
  inline int edges_size() const;
  inline void clear_edges();
  static const int kEdgesFieldNumber = 3;
  inline const ::Vector2IntPB& edges(int index) const;
  inline ::Vector2IntPB* mutable_edges(int index);
  inline ::Vector2IntPB* add_edges();
  inline const ::google::protobuf::RepeatedPtrField< ::Vector2IntPB >&
      edges() const;
  inline ::google::protobuf::RepeatedPtrField< ::Vector2IntPB >*
      mutable_edges();

  // @@protoc_insertion_point(class_scope:MapPositionGraph)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Vector3PB > vertices_;
  ::google::protobuf::RepeatedPtrField< ::Vector2IntPB > edges_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MapCliRpc_2eproto();
  friend void protobuf_AssignDesc_MapCliRpc_2eproto();
  friend void protobuf_ShutdownFile_MapCliRpc_2eproto();

  void InitAsDefaultInstance();
  static MapPositionGraph* default_instance_;
};
// ===================================================================


// ===================================================================

// MapSceneData

// optional sint32 MapId = 1 [default = -1];
inline bool MapSceneData::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapSceneData::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapSceneData::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapSceneData::clear_mapid() {
  mapid_ = -1;
  clear_has_mapid();
}
inline ::google::protobuf::int32 MapSceneData::mapid() const {
  return mapid_;
}
inline void MapSceneData::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional string SceneName = 2;
inline bool MapSceneData::has_scenename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapSceneData::set_has_scenename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapSceneData::clear_has_scenename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapSceneData::clear_scenename() {
  if (scenename_ != &::google::protobuf::internal::kEmptyString) {
    scenename_->clear();
  }
  clear_has_scenename();
}
inline const ::std::string& MapSceneData::scenename() const {
  return *scenename_;
}
inline void MapSceneData::set_scenename(const ::std::string& value) {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::kEmptyString) {
    scenename_ = new ::std::string;
  }
  scenename_->assign(value);
}
inline void MapSceneData::set_scenename(const char* value) {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::kEmptyString) {
    scenename_ = new ::std::string;
  }
  scenename_->assign(value);
}
inline void MapSceneData::set_scenename(const char* value, size_t size) {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::kEmptyString) {
    scenename_ = new ::std::string;
  }
  scenename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_scenename() {
  set_has_scenename();
  if (scenename_ == &::google::protobuf::internal::kEmptyString) {
    scenename_ = new ::std::string;
  }
  return scenename_;
}
inline ::std::string* MapSceneData::release_scenename() {
  clear_has_scenename();
  if (scenename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scenename_;
    scenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_scenename(::std::string* scenename) {
  if (scenename_ != &::google::protobuf::internal::kEmptyString) {
    delete scenename_;
  }
  if (scenename) {
    set_has_scenename();
    scenename_ = scenename;
  } else {
    clear_has_scenename();
    scenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SceneFileName = 20;
inline bool MapSceneData::has_scenefilename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapSceneData::set_has_scenefilename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapSceneData::clear_has_scenefilename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapSceneData::clear_scenefilename() {
  if (scenefilename_ != &::google::protobuf::internal::kEmptyString) {
    scenefilename_->clear();
  }
  clear_has_scenefilename();
}
inline const ::std::string& MapSceneData::scenefilename() const {
  return *scenefilename_;
}
inline void MapSceneData::set_scenefilename(const ::std::string& value) {
  set_has_scenefilename();
  if (scenefilename_ == &::google::protobuf::internal::kEmptyString) {
    scenefilename_ = new ::std::string;
  }
  scenefilename_->assign(value);
}
inline void MapSceneData::set_scenefilename(const char* value) {
  set_has_scenefilename();
  if (scenefilename_ == &::google::protobuf::internal::kEmptyString) {
    scenefilename_ = new ::std::string;
  }
  scenefilename_->assign(value);
}
inline void MapSceneData::set_scenefilename(const char* value, size_t size) {
  set_has_scenefilename();
  if (scenefilename_ == &::google::protobuf::internal::kEmptyString) {
    scenefilename_ = new ::std::string;
  }
  scenefilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_scenefilename() {
  set_has_scenefilename();
  if (scenefilename_ == &::google::protobuf::internal::kEmptyString) {
    scenefilename_ = new ::std::string;
  }
  return scenefilename_;
}
inline ::std::string* MapSceneData::release_scenefilename() {
  clear_has_scenefilename();
  if (scenefilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scenefilename_;
    scenefilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_scenefilename(::std::string* scenefilename) {
  if (scenefilename_ != &::google::protobuf::internal::kEmptyString) {
    delete scenefilename_;
  }
  if (scenefilename) {
    set_has_scenefilename();
    scenefilename_ = scenefilename;
  } else {
    clear_has_scenefilename();
    scenefilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ClientSceneName = 19;
inline bool MapSceneData::has_clientscenename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapSceneData::set_has_clientscenename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapSceneData::clear_has_clientscenename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapSceneData::clear_clientscenename() {
  if (clientscenename_ != &::google::protobuf::internal::kEmptyString) {
    clientscenename_->clear();
  }
  clear_has_clientscenename();
}
inline const ::std::string& MapSceneData::clientscenename() const {
  return *clientscenename_;
}
inline void MapSceneData::set_clientscenename(const ::std::string& value) {
  set_has_clientscenename();
  if (clientscenename_ == &::google::protobuf::internal::kEmptyString) {
    clientscenename_ = new ::std::string;
  }
  clientscenename_->assign(value);
}
inline void MapSceneData::set_clientscenename(const char* value) {
  set_has_clientscenename();
  if (clientscenename_ == &::google::protobuf::internal::kEmptyString) {
    clientscenename_ = new ::std::string;
  }
  clientscenename_->assign(value);
}
inline void MapSceneData::set_clientscenename(const char* value, size_t size) {
  set_has_clientscenename();
  if (clientscenename_ == &::google::protobuf::internal::kEmptyString) {
    clientscenename_ = new ::std::string;
  }
  clientscenename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_clientscenename() {
  set_has_clientscenename();
  if (clientscenename_ == &::google::protobuf::internal::kEmptyString) {
    clientscenename_ = new ::std::string;
  }
  return clientscenename_;
}
inline ::std::string* MapSceneData::release_clientscenename() {
  clear_has_clientscenename();
  if (clientscenename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientscenename_;
    clientscenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_clientscenename(::std::string* clientscenename) {
  if (clientscenename_ != &::google::protobuf::internal::kEmptyString) {
    delete clientscenename_;
  }
  if (clientscenename) {
    set_has_clientscenename();
    clientscenename_ = clientscenename;
  } else {
    clear_has_clientscenename();
    clientscenename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MapSimplify = 3;
inline bool MapSceneData::has_mapsimplify() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapSceneData::set_has_mapsimplify() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapSceneData::clear_has_mapsimplify() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapSceneData::clear_mapsimplify() {
  if (mapsimplify_ != &::google::protobuf::internal::kEmptyString) {
    mapsimplify_->clear();
  }
  clear_has_mapsimplify();
}
inline const ::std::string& MapSceneData::mapsimplify() const {
  return *mapsimplify_;
}
inline void MapSceneData::set_mapsimplify(const ::std::string& value) {
  set_has_mapsimplify();
  if (mapsimplify_ == &::google::protobuf::internal::kEmptyString) {
    mapsimplify_ = new ::std::string;
  }
  mapsimplify_->assign(value);
}
inline void MapSceneData::set_mapsimplify(const char* value) {
  set_has_mapsimplify();
  if (mapsimplify_ == &::google::protobuf::internal::kEmptyString) {
    mapsimplify_ = new ::std::string;
  }
  mapsimplify_->assign(value);
}
inline void MapSceneData::set_mapsimplify(const char* value, size_t size) {
  set_has_mapsimplify();
  if (mapsimplify_ == &::google::protobuf::internal::kEmptyString) {
    mapsimplify_ = new ::std::string;
  }
  mapsimplify_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_mapsimplify() {
  set_has_mapsimplify();
  if (mapsimplify_ == &::google::protobuf::internal::kEmptyString) {
    mapsimplify_ = new ::std::string;
  }
  return mapsimplify_;
}
inline ::std::string* MapSceneData::release_mapsimplify() {
  clear_has_mapsimplify();
  if (mapsimplify_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mapsimplify_;
    mapsimplify_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_mapsimplify(::std::string* mapsimplify) {
  if (mapsimplify_ != &::google::protobuf::internal::kEmptyString) {
    delete mapsimplify_;
  }
  if (mapsimplify) {
    set_has_mapsimplify();
    mapsimplify_ = mapsimplify;
  } else {
    clear_has_mapsimplify();
    mapsimplify_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 MapSimplifyRotate1 = 4 [default = -1];
inline bool MapSceneData::has_mapsimplifyrotate1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapSceneData::set_has_mapsimplifyrotate1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapSceneData::clear_has_mapsimplifyrotate1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapSceneData::clear_mapsimplifyrotate1() {
  mapsimplifyrotate1_ = -1;
  clear_has_mapsimplifyrotate1();
}
inline ::google::protobuf::int32 MapSceneData::mapsimplifyrotate1() const {
  return mapsimplifyrotate1_;
}
inline void MapSceneData::set_mapsimplifyrotate1(::google::protobuf::int32 value) {
  set_has_mapsimplifyrotate1();
  mapsimplifyrotate1_ = value;
}

// optional sint32 MapSimplifyRotate2 = 5 [default = -1];
inline bool MapSceneData::has_mapsimplifyrotate2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapSceneData::set_has_mapsimplifyrotate2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapSceneData::clear_has_mapsimplifyrotate2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapSceneData::clear_mapsimplifyrotate2() {
  mapsimplifyrotate2_ = -1;
  clear_has_mapsimplifyrotate2();
}
inline ::google::protobuf::int32 MapSceneData::mapsimplifyrotate2() const {
  return mapsimplifyrotate2_;
}
inline void MapSceneData::set_mapsimplifyrotate2(::google::protobuf::int32 value) {
  set_has_mapsimplifyrotate2();
  mapsimplifyrotate2_ = value;
}

// optional float MapPosX = 6 [default = -1];
inline bool MapSceneData::has_mapposx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapSceneData::set_has_mapposx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapSceneData::clear_has_mapposx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapSceneData::clear_mapposx() {
  mapposx_ = -1;
  clear_has_mapposx();
}
inline float MapSceneData::mapposx() const {
  return mapposx_;
}
inline void MapSceneData::set_mapposx(float value) {
  set_has_mapposx();
  mapposx_ = value;
}

// optional float MapPosY = 7 [default = -1];
inline bool MapSceneData::has_mapposy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapSceneData::set_has_mapposy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapSceneData::clear_has_mapposy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapSceneData::clear_mapposy() {
  mapposy_ = -1;
  clear_has_mapposy();
}
inline float MapSceneData::mapposy() const {
  return mapposy_;
}
inline void MapSceneData::set_mapposy(float value) {
  set_has_mapposy();
  mapposy_ = value;
}

// optional float MapPivotX = 8 [default = -1];
inline bool MapSceneData::has_mappivotx() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapSceneData::set_has_mappivotx() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapSceneData::clear_has_mappivotx() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapSceneData::clear_mappivotx() {
  mappivotx_ = -1;
  clear_has_mappivotx();
}
inline float MapSceneData::mappivotx() const {
  return mappivotx_;
}
inline void MapSceneData::set_mappivotx(float value) {
  set_has_mappivotx();
  mappivotx_ = value;
}

// optional float MapPivotY = 9 [default = -1];
inline bool MapSceneData::has_mappivoty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapSceneData::set_has_mappivoty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapSceneData::clear_has_mappivoty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapSceneData::clear_mappivoty() {
  mappivoty_ = -1;
  clear_has_mappivoty();
}
inline float MapSceneData::mappivoty() const {
  return mappivoty_;
}
inline void MapSceneData::set_mappivoty(float value) {
  set_has_mappivoty();
  mappivoty_ = value;
}

// optional float UIWorldRatio = 10 [default = -1];
inline bool MapSceneData::has_uiworldratio() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapSceneData::set_has_uiworldratio() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapSceneData::clear_has_uiworldratio() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapSceneData::clear_uiworldratio() {
  uiworldratio_ = -1;
  clear_has_uiworldratio();
}
inline float MapSceneData::uiworldratio() const {
  return uiworldratio_;
}
inline void MapSceneData::set_uiworldratio(float value) {
  set_has_uiworldratio();
  uiworldratio_ = value;
}

// optional string MapDetailed = 11;
inline bool MapSceneData::has_mapdetailed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapSceneData::set_has_mapdetailed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapSceneData::clear_has_mapdetailed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapSceneData::clear_mapdetailed() {
  if (mapdetailed_ != &::google::protobuf::internal::kEmptyString) {
    mapdetailed_->clear();
  }
  clear_has_mapdetailed();
}
inline const ::std::string& MapSceneData::mapdetailed() const {
  return *mapdetailed_;
}
inline void MapSceneData::set_mapdetailed(const ::std::string& value) {
  set_has_mapdetailed();
  if (mapdetailed_ == &::google::protobuf::internal::kEmptyString) {
    mapdetailed_ = new ::std::string;
  }
  mapdetailed_->assign(value);
}
inline void MapSceneData::set_mapdetailed(const char* value) {
  set_has_mapdetailed();
  if (mapdetailed_ == &::google::protobuf::internal::kEmptyString) {
    mapdetailed_ = new ::std::string;
  }
  mapdetailed_->assign(value);
}
inline void MapSceneData::set_mapdetailed(const char* value, size_t size) {
  set_has_mapdetailed();
  if (mapdetailed_ == &::google::protobuf::internal::kEmptyString) {
    mapdetailed_ = new ::std::string;
  }
  mapdetailed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_mapdetailed() {
  set_has_mapdetailed();
  if (mapdetailed_ == &::google::protobuf::internal::kEmptyString) {
    mapdetailed_ = new ::std::string;
  }
  return mapdetailed_;
}
inline ::std::string* MapSceneData::release_mapdetailed() {
  clear_has_mapdetailed();
  if (mapdetailed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mapdetailed_;
    mapdetailed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_mapdetailed(::std::string* mapdetailed) {
  if (mapdetailed_ != &::google::protobuf::internal::kEmptyString) {
    delete mapdetailed_;
  }
  if (mapdetailed) {
    set_has_mapdetailed();
    mapdetailed_ = mapdetailed;
  } else {
    clear_has_mapdetailed();
    mapdetailed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 MapDetailedRotate1 = 12 [default = -1];
inline bool MapSceneData::has_mapdetailedrotate1() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MapSceneData::set_has_mapdetailedrotate1() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MapSceneData::clear_has_mapdetailedrotate1() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MapSceneData::clear_mapdetailedrotate1() {
  mapdetailedrotate1_ = -1;
  clear_has_mapdetailedrotate1();
}
inline ::google::protobuf::int32 MapSceneData::mapdetailedrotate1() const {
  return mapdetailedrotate1_;
}
inline void MapSceneData::set_mapdetailedrotate1(::google::protobuf::int32 value) {
  set_has_mapdetailedrotate1();
  mapdetailedrotate1_ = value;
}

// optional sint32 MapDetailedRotate2 = 13 [default = -1];
inline bool MapSceneData::has_mapdetailedrotate2() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapSceneData::set_has_mapdetailedrotate2() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapSceneData::clear_has_mapdetailedrotate2() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapSceneData::clear_mapdetailedrotate2() {
  mapdetailedrotate2_ = -1;
  clear_has_mapdetailedrotate2();
}
inline ::google::protobuf::int32 MapSceneData::mapdetailedrotate2() const {
  return mapdetailedrotate2_;
}
inline void MapSceneData::set_mapdetailedrotate2(::google::protobuf::int32 value) {
  set_has_mapdetailedrotate2();
  mapdetailedrotate2_ = value;
}

// optional float ServerUIRadio = 14 [default = -1];
inline bool MapSceneData::has_serveruiradio() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MapSceneData::set_has_serveruiradio() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MapSceneData::clear_has_serveruiradio() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MapSceneData::clear_serveruiradio() {
  serveruiradio_ = -1;
  clear_has_serveruiradio();
}
inline float MapSceneData::serveruiradio() const {
  return serveruiradio_;
}
inline void MapSceneData::set_serveruiradio(float value) {
  set_has_serveruiradio();
  serveruiradio_ = value;
}

// optional .MapPvpData Pvp = 15;
inline bool MapSceneData::has_pvp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MapSceneData::set_has_pvp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MapSceneData::clear_has_pvp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MapSceneData::clear_pvp() {
  if (pvp_ != NULL) pvp_->::MapPvpData::Clear();
  clear_has_pvp();
}
inline const ::MapPvpData& MapSceneData::pvp() const {
  return pvp_ != NULL ? *pvp_ : *default_instance_->pvp_;
}
inline ::MapPvpData* MapSceneData::mutable_pvp() {
  set_has_pvp();
  if (pvp_ == NULL) pvp_ = new ::MapPvpData;
  return pvp_;
}
inline ::MapPvpData* MapSceneData::release_pvp() {
  clear_has_pvp();
  ::MapPvpData* temp = pvp_;
  pvp_ = NULL;
  return temp;
}
inline void MapSceneData::set_allocated_pvp(::MapPvpData* pvp) {
  delete pvp_;
  pvp_ = pvp;
  if (pvp) {
    set_has_pvp();
  } else {
    clear_has_pvp();
  }
}

// repeated .MapSprayData Sprays = 16;
inline int MapSceneData::sprays_size() const {
  return sprays_.size();
}
inline void MapSceneData::clear_sprays() {
  sprays_.Clear();
}
inline const ::MapSprayData& MapSceneData::sprays(int index) const {
  return sprays_.Get(index);
}
inline ::MapSprayData* MapSceneData::mutable_sprays(int index) {
  return sprays_.Mutable(index);
}
inline ::MapSprayData* MapSceneData::add_sprays() {
  return sprays_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapSprayData >&
MapSceneData::sprays() const {
  return sprays_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapSprayData >*
MapSceneData::mutable_sprays() {
  return &sprays_;
}

// repeated .MapTeamData Teams = 17;
inline int MapSceneData::teams_size() const {
  return teams_.size();
}
inline void MapSceneData::clear_teams() {
  teams_.Clear();
}
inline const ::MapTeamData& MapSceneData::teams(int index) const {
  return teams_.Get(index);
}
inline ::MapTeamData* MapSceneData::mutable_teams(int index) {
  return teams_.Mutable(index);
}
inline ::MapTeamData* MapSceneData::add_teams() {
  return teams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapTeamData >&
MapSceneData::teams() const {
  return teams_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapTeamData >*
MapSceneData::mutable_teams() {
  return &teams_;
}

// optional string LowModel = 18;
inline bool MapSceneData::has_lowmodel() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MapSceneData::set_has_lowmodel() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MapSceneData::clear_has_lowmodel() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MapSceneData::clear_lowmodel() {
  if (lowmodel_ != &::google::protobuf::internal::kEmptyString) {
    lowmodel_->clear();
  }
  clear_has_lowmodel();
}
inline const ::std::string& MapSceneData::lowmodel() const {
  return *lowmodel_;
}
inline void MapSceneData::set_lowmodel(const ::std::string& value) {
  set_has_lowmodel();
  if (lowmodel_ == &::google::protobuf::internal::kEmptyString) {
    lowmodel_ = new ::std::string;
  }
  lowmodel_->assign(value);
}
inline void MapSceneData::set_lowmodel(const char* value) {
  set_has_lowmodel();
  if (lowmodel_ == &::google::protobuf::internal::kEmptyString) {
    lowmodel_ = new ::std::string;
  }
  lowmodel_->assign(value);
}
inline void MapSceneData::set_lowmodel(const char* value, size_t size) {
  set_has_lowmodel();
  if (lowmodel_ == &::google::protobuf::internal::kEmptyString) {
    lowmodel_ = new ::std::string;
  }
  lowmodel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_lowmodel() {
  set_has_lowmodel();
  if (lowmodel_ == &::google::protobuf::internal::kEmptyString) {
    lowmodel_ = new ::std::string;
  }
  return lowmodel_;
}
inline ::std::string* MapSceneData::release_lowmodel() {
  clear_has_lowmodel();
  if (lowmodel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lowmodel_;
    lowmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_lowmodel(::std::string* lowmodel) {
  if (lowmodel_ != &::google::protobuf::internal::kEmptyString) {
    delete lowmodel_;
  }
  if (lowmodel) {
    set_has_lowmodel();
    lowmodel_ = lowmodel;
  } else {
    clear_has_lowmodel();
    lowmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float AlphaSpeed = 21 [default = -1];
inline bool MapSceneData::has_alphaspeed() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MapSceneData::set_has_alphaspeed() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MapSceneData::clear_has_alphaspeed() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MapSceneData::clear_alphaspeed() {
  alphaspeed_ = -1;
  clear_has_alphaspeed();
}
inline float MapSceneData::alphaspeed() const {
  return alphaspeed_;
}
inline void MapSceneData::set_alphaspeed(float value) {
  set_has_alphaspeed();
  alphaspeed_ = value;
}

// optional float TransferRadius = 22 [default = -1];
inline bool MapSceneData::has_transferradius() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MapSceneData::set_has_transferradius() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MapSceneData::clear_has_transferradius() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MapSceneData::clear_transferradius() {
  transferradius_ = -1;
  clear_has_transferradius();
}
inline float MapSceneData::transferradius() const {
  return transferradius_;
}
inline void MapSceneData::set_transferradius(float value) {
  set_has_transferradius();
  transferradius_ = value;
}

// optional string MapEffectAura = 23;
inline bool MapSceneData::has_mapeffectaura() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MapSceneData::set_has_mapeffectaura() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MapSceneData::clear_has_mapeffectaura() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MapSceneData::clear_mapeffectaura() {
  if (mapeffectaura_ != &::google::protobuf::internal::kEmptyString) {
    mapeffectaura_->clear();
  }
  clear_has_mapeffectaura();
}
inline const ::std::string& MapSceneData::mapeffectaura() const {
  return *mapeffectaura_;
}
inline void MapSceneData::set_mapeffectaura(const ::std::string& value) {
  set_has_mapeffectaura();
  if (mapeffectaura_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectaura_ = new ::std::string;
  }
  mapeffectaura_->assign(value);
}
inline void MapSceneData::set_mapeffectaura(const char* value) {
  set_has_mapeffectaura();
  if (mapeffectaura_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectaura_ = new ::std::string;
  }
  mapeffectaura_->assign(value);
}
inline void MapSceneData::set_mapeffectaura(const char* value, size_t size) {
  set_has_mapeffectaura();
  if (mapeffectaura_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectaura_ = new ::std::string;
  }
  mapeffectaura_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_mapeffectaura() {
  set_has_mapeffectaura();
  if (mapeffectaura_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectaura_ = new ::std::string;
  }
  return mapeffectaura_;
}
inline ::std::string* MapSceneData::release_mapeffectaura() {
  clear_has_mapeffectaura();
  if (mapeffectaura_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mapeffectaura_;
    mapeffectaura_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_mapeffectaura(::std::string* mapeffectaura) {
  if (mapeffectaura_ != &::google::protobuf::internal::kEmptyString) {
    delete mapeffectaura_;
  }
  if (mapeffectaura) {
    set_has_mapeffectaura();
    mapeffectaura_ = mapeffectaura;
  } else {
    clear_has_mapeffectaura();
    mapeffectaura_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MapEffecttransfer = 24;
inline bool MapSceneData::has_mapeffecttransfer() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MapSceneData::set_has_mapeffecttransfer() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MapSceneData::clear_has_mapeffecttransfer() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MapSceneData::clear_mapeffecttransfer() {
  if (mapeffecttransfer_ != &::google::protobuf::internal::kEmptyString) {
    mapeffecttransfer_->clear();
  }
  clear_has_mapeffecttransfer();
}
inline const ::std::string& MapSceneData::mapeffecttransfer() const {
  return *mapeffecttransfer_;
}
inline void MapSceneData::set_mapeffecttransfer(const ::std::string& value) {
  set_has_mapeffecttransfer();
  if (mapeffecttransfer_ == &::google::protobuf::internal::kEmptyString) {
    mapeffecttransfer_ = new ::std::string;
  }
  mapeffecttransfer_->assign(value);
}
inline void MapSceneData::set_mapeffecttransfer(const char* value) {
  set_has_mapeffecttransfer();
  if (mapeffecttransfer_ == &::google::protobuf::internal::kEmptyString) {
    mapeffecttransfer_ = new ::std::string;
  }
  mapeffecttransfer_->assign(value);
}
inline void MapSceneData::set_mapeffecttransfer(const char* value, size_t size) {
  set_has_mapeffecttransfer();
  if (mapeffecttransfer_ == &::google::protobuf::internal::kEmptyString) {
    mapeffecttransfer_ = new ::std::string;
  }
  mapeffecttransfer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_mapeffecttransfer() {
  set_has_mapeffecttransfer();
  if (mapeffecttransfer_ == &::google::protobuf::internal::kEmptyString) {
    mapeffecttransfer_ = new ::std::string;
  }
  return mapeffecttransfer_;
}
inline ::std::string* MapSceneData::release_mapeffecttransfer() {
  clear_has_mapeffecttransfer();
  if (mapeffecttransfer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mapeffecttransfer_;
    mapeffecttransfer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_mapeffecttransfer(::std::string* mapeffecttransfer) {
  if (mapeffecttransfer_ != &::google::protobuf::internal::kEmptyString) {
    delete mapeffecttransfer_;
  }
  if (mapeffecttransfer) {
    set_has_mapeffecttransfer();
    mapeffecttransfer_ = mapeffecttransfer;
  } else {
    clear_has_mapeffecttransfer();
    mapeffecttransfer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MapEffectArrive = 25;
inline bool MapSceneData::has_mapeffectarrive() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MapSceneData::set_has_mapeffectarrive() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MapSceneData::clear_has_mapeffectarrive() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MapSceneData::clear_mapeffectarrive() {
  if (mapeffectarrive_ != &::google::protobuf::internal::kEmptyString) {
    mapeffectarrive_->clear();
  }
  clear_has_mapeffectarrive();
}
inline const ::std::string& MapSceneData::mapeffectarrive() const {
  return *mapeffectarrive_;
}
inline void MapSceneData::set_mapeffectarrive(const ::std::string& value) {
  set_has_mapeffectarrive();
  if (mapeffectarrive_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectarrive_ = new ::std::string;
  }
  mapeffectarrive_->assign(value);
}
inline void MapSceneData::set_mapeffectarrive(const char* value) {
  set_has_mapeffectarrive();
  if (mapeffectarrive_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectarrive_ = new ::std::string;
  }
  mapeffectarrive_->assign(value);
}
inline void MapSceneData::set_mapeffectarrive(const char* value, size_t size) {
  set_has_mapeffectarrive();
  if (mapeffectarrive_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectarrive_ = new ::std::string;
  }
  mapeffectarrive_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSceneData::mutable_mapeffectarrive() {
  set_has_mapeffectarrive();
  if (mapeffectarrive_ == &::google::protobuf::internal::kEmptyString) {
    mapeffectarrive_ = new ::std::string;
  }
  return mapeffectarrive_;
}
inline ::std::string* MapSceneData::release_mapeffectarrive() {
  clear_has_mapeffectarrive();
  if (mapeffectarrive_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mapeffectarrive_;
    mapeffectarrive_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSceneData::set_allocated_mapeffectarrive(::std::string* mapeffectarrive) {
  if (mapeffectarrive_ != &::google::protobuf::internal::kEmptyString) {
    delete mapeffectarrive_;
  }
  if (mapeffectarrive) {
    set_has_mapeffectarrive();
    mapeffectarrive_ = mapeffectarrive;
  } else {
    clear_has_mapeffectarrive();
    mapeffectarrive_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .MapPositionGraph PathGraphs = 26;
inline int MapSceneData::pathgraphs_size() const {
  return pathgraphs_.size();
}
inline void MapSceneData::clear_pathgraphs() {
  pathgraphs_.Clear();
}
inline const ::MapPositionGraph& MapSceneData::pathgraphs(int index) const {
  return pathgraphs_.Get(index);
}
inline ::MapPositionGraph* MapSceneData::mutable_pathgraphs(int index) {
  return pathgraphs_.Mutable(index);
}
inline ::MapPositionGraph* MapSceneData::add_pathgraphs() {
  return pathgraphs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapPositionGraph >&
MapSceneData::pathgraphs() const {
  return pathgraphs_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapPositionGraph >*
MapSceneData::mutable_pathgraphs() {
  return &pathgraphs_;
}

// -------------------------------------------------------------------

// MapBasePlaymodeData

// optional sint32 Type = 5 [default = -1];
inline bool MapBasePlaymodeData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapBasePlaymodeData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapBasePlaymodeData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapBasePlaymodeData::clear_type() {
  type_ = -1;
  clear_has_type();
}
inline ::google::protobuf::int32 MapBasePlaymodeData::type() const {
  return type_;
}
inline void MapBasePlaymodeData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string Desc1 = 1;
inline bool MapBasePlaymodeData::has_desc1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapBasePlaymodeData::set_has_desc1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapBasePlaymodeData::clear_has_desc1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapBasePlaymodeData::clear_desc1() {
  if (desc1_ != &::google::protobuf::internal::kEmptyString) {
    desc1_->clear();
  }
  clear_has_desc1();
}
inline const ::std::string& MapBasePlaymodeData::desc1() const {
  return *desc1_;
}
inline void MapBasePlaymodeData::set_desc1(const ::std::string& value) {
  set_has_desc1();
  if (desc1_ == &::google::protobuf::internal::kEmptyString) {
    desc1_ = new ::std::string;
  }
  desc1_->assign(value);
}
inline void MapBasePlaymodeData::set_desc1(const char* value) {
  set_has_desc1();
  if (desc1_ == &::google::protobuf::internal::kEmptyString) {
    desc1_ = new ::std::string;
  }
  desc1_->assign(value);
}
inline void MapBasePlaymodeData::set_desc1(const char* value, size_t size) {
  set_has_desc1();
  if (desc1_ == &::google::protobuf::internal::kEmptyString) {
    desc1_ = new ::std::string;
  }
  desc1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapBasePlaymodeData::mutable_desc1() {
  set_has_desc1();
  if (desc1_ == &::google::protobuf::internal::kEmptyString) {
    desc1_ = new ::std::string;
  }
  return desc1_;
}
inline ::std::string* MapBasePlaymodeData::release_desc1() {
  clear_has_desc1();
  if (desc1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc1_;
    desc1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapBasePlaymodeData::set_allocated_desc1(::std::string* desc1) {
  if (desc1_ != &::google::protobuf::internal::kEmptyString) {
    delete desc1_;
  }
  if (desc1) {
    set_has_desc1();
    desc1_ = desc1;
  } else {
    clear_has_desc1();
    desc1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Desc2 = 2;
inline bool MapBasePlaymodeData::has_desc2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapBasePlaymodeData::set_has_desc2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapBasePlaymodeData::clear_has_desc2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapBasePlaymodeData::clear_desc2() {
  if (desc2_ != &::google::protobuf::internal::kEmptyString) {
    desc2_->clear();
  }
  clear_has_desc2();
}
inline const ::std::string& MapBasePlaymodeData::desc2() const {
  return *desc2_;
}
inline void MapBasePlaymodeData::set_desc2(const ::std::string& value) {
  set_has_desc2();
  if (desc2_ == &::google::protobuf::internal::kEmptyString) {
    desc2_ = new ::std::string;
  }
  desc2_->assign(value);
}
inline void MapBasePlaymodeData::set_desc2(const char* value) {
  set_has_desc2();
  if (desc2_ == &::google::protobuf::internal::kEmptyString) {
    desc2_ = new ::std::string;
  }
  desc2_->assign(value);
}
inline void MapBasePlaymodeData::set_desc2(const char* value, size_t size) {
  set_has_desc2();
  if (desc2_ == &::google::protobuf::internal::kEmptyString) {
    desc2_ = new ::std::string;
  }
  desc2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapBasePlaymodeData::mutable_desc2() {
  set_has_desc2();
  if (desc2_ == &::google::protobuf::internal::kEmptyString) {
    desc2_ = new ::std::string;
  }
  return desc2_;
}
inline ::std::string* MapBasePlaymodeData::release_desc2() {
  clear_has_desc2();
  if (desc2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc2_;
    desc2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapBasePlaymodeData::set_allocated_desc2(::std::string* desc2) {
  if (desc2_ != &::google::protobuf::internal::kEmptyString) {
    delete desc2_;
  }
  if (desc2) {
    set_has_desc2();
    desc2_ = desc2;
  } else {
    clear_has_desc2();
    desc2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ModeName = 3;
inline bool MapBasePlaymodeData::has_modename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapBasePlaymodeData::set_has_modename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapBasePlaymodeData::clear_has_modename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapBasePlaymodeData::clear_modename() {
  if (modename_ != &::google::protobuf::internal::kEmptyString) {
    modename_->clear();
  }
  clear_has_modename();
}
inline const ::std::string& MapBasePlaymodeData::modename() const {
  return *modename_;
}
inline void MapBasePlaymodeData::set_modename(const ::std::string& value) {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  modename_->assign(value);
}
inline void MapBasePlaymodeData::set_modename(const char* value) {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  modename_->assign(value);
}
inline void MapBasePlaymodeData::set_modename(const char* value, size_t size) {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  modename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapBasePlaymodeData::mutable_modename() {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  return modename_;
}
inline ::std::string* MapBasePlaymodeData::release_modename() {
  clear_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modename_;
    modename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapBasePlaymodeData::set_allocated_modename(::std::string* modename) {
  if (modename_ != &::google::protobuf::internal::kEmptyString) {
    delete modename_;
  }
  if (modename) {
    set_has_modename();
    modename_ = modename;
  } else {
    clear_has_modename();
    modename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Uibg = 4;
inline bool MapBasePlaymodeData::has_uibg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapBasePlaymodeData::set_has_uibg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapBasePlaymodeData::clear_has_uibg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapBasePlaymodeData::clear_uibg() {
  if (uibg_ != &::google::protobuf::internal::kEmptyString) {
    uibg_->clear();
  }
  clear_has_uibg();
}
inline const ::std::string& MapBasePlaymodeData::uibg() const {
  return *uibg_;
}
inline void MapBasePlaymodeData::set_uibg(const ::std::string& value) {
  set_has_uibg();
  if (uibg_ == &::google::protobuf::internal::kEmptyString) {
    uibg_ = new ::std::string;
  }
  uibg_->assign(value);
}
inline void MapBasePlaymodeData::set_uibg(const char* value) {
  set_has_uibg();
  if (uibg_ == &::google::protobuf::internal::kEmptyString) {
    uibg_ = new ::std::string;
  }
  uibg_->assign(value);
}
inline void MapBasePlaymodeData::set_uibg(const char* value, size_t size) {
  set_has_uibg();
  if (uibg_ == &::google::protobuf::internal::kEmptyString) {
    uibg_ = new ::std::string;
  }
  uibg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapBasePlaymodeData::mutable_uibg() {
  set_has_uibg();
  if (uibg_ == &::google::protobuf::internal::kEmptyString) {
    uibg_ = new ::std::string;
  }
  return uibg_;
}
inline ::std::string* MapBasePlaymodeData::release_uibg() {
  clear_has_uibg();
  if (uibg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uibg_;
    uibg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapBasePlaymodeData::set_allocated_uibg(::std::string* uibg) {
  if (uibg_ != &::google::protobuf::internal::kEmptyString) {
    delete uibg_;
  }
  if (uibg) {
    set_has_uibg();
    uibg_ = uibg;
  } else {
    clear_has_uibg();
    uibg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .MapCameraData MainCameras = 6;
inline int MapBasePlaymodeData::maincameras_size() const {
  return maincameras_.size();
}
inline void MapBasePlaymodeData::clear_maincameras() {
  maincameras_.Clear();
}
inline const ::MapCameraData& MapBasePlaymodeData::maincameras(int index) const {
  return maincameras_.Get(index);
}
inline ::MapCameraData* MapBasePlaymodeData::mutable_maincameras(int index) {
  return maincameras_.Mutable(index);
}
inline ::MapCameraData* MapBasePlaymodeData::add_maincameras() {
  return maincameras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapCameraData >&
MapBasePlaymodeData::maincameras() const {
  return maincameras_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapCameraData >*
MapBasePlaymodeData::mutable_maincameras() {
  return &maincameras_;
}

// repeated .MapCameraData SlaveCameras = 7;
inline int MapBasePlaymodeData::slavecameras_size() const {
  return slavecameras_.size();
}
inline void MapBasePlaymodeData::clear_slavecameras() {
  slavecameras_.Clear();
}
inline const ::MapCameraData& MapBasePlaymodeData::slavecameras(int index) const {
  return slavecameras_.Get(index);
}
inline ::MapCameraData* MapBasePlaymodeData::mutable_slavecameras(int index) {
  return slavecameras_.Mutable(index);
}
inline ::MapCameraData* MapBasePlaymodeData::add_slavecameras() {
  return slavecameras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapCameraData >&
MapBasePlaymodeData::slavecameras() const {
  return slavecameras_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapCameraData >*
MapBasePlaymodeData::mutable_slavecameras() {
  return &slavecameras_;
}

// repeated .MapLiftingConfig Liftings = 8;
inline int MapBasePlaymodeData::liftings_size() const {
  return liftings_.size();
}
inline void MapBasePlaymodeData::clear_liftings() {
  liftings_.Clear();
}
inline const ::MapLiftingConfig& MapBasePlaymodeData::liftings(int index) const {
  return liftings_.Get(index);
}
inline ::MapLiftingConfig* MapBasePlaymodeData::mutable_liftings(int index) {
  return liftings_.Mutable(index);
}
inline ::MapLiftingConfig* MapBasePlaymodeData::add_liftings() {
  return liftings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapLiftingConfig >&
MapBasePlaymodeData::liftings() const {
  return liftings_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapLiftingConfig >*
MapBasePlaymodeData::mutable_liftings() {
  return &liftings_;
}

// optional string CharacterAnim = 9;
inline bool MapBasePlaymodeData::has_characteranim() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapBasePlaymodeData::set_has_characteranim() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapBasePlaymodeData::clear_has_characteranim() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapBasePlaymodeData::clear_characteranim() {
  if (characteranim_ != &::google::protobuf::internal::kEmptyString) {
    characteranim_->clear();
  }
  clear_has_characteranim();
}
inline const ::std::string& MapBasePlaymodeData::characteranim() const {
  return *characteranim_;
}
inline void MapBasePlaymodeData::set_characteranim(const ::std::string& value) {
  set_has_characteranim();
  if (characteranim_ == &::google::protobuf::internal::kEmptyString) {
    characteranim_ = new ::std::string;
  }
  characteranim_->assign(value);
}
inline void MapBasePlaymodeData::set_characteranim(const char* value) {
  set_has_characteranim();
  if (characteranim_ == &::google::protobuf::internal::kEmptyString) {
    characteranim_ = new ::std::string;
  }
  characteranim_->assign(value);
}
inline void MapBasePlaymodeData::set_characteranim(const char* value, size_t size) {
  set_has_characteranim();
  if (characteranim_ == &::google::protobuf::internal::kEmptyString) {
    characteranim_ = new ::std::string;
  }
  characteranim_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapBasePlaymodeData::mutable_characteranim() {
  set_has_characteranim();
  if (characteranim_ == &::google::protobuf::internal::kEmptyString) {
    characteranim_ = new ::std::string;
  }
  return characteranim_;
}
inline ::std::string* MapBasePlaymodeData::release_characteranim() {
  clear_has_characteranim();
  if (characteranim_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = characteranim_;
    characteranim_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapBasePlaymodeData::set_allocated_characteranim(::std::string* characteranim) {
  if (characteranim_ != &::google::protobuf::internal::kEmptyString) {
    delete characteranim_;
  }
  if (characteranim) {
    set_has_characteranim();
    characteranim_ = characteranim;
  } else {
    clear_has_characteranim();
    characteranim_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ReadyFile = 10;
inline bool MapBasePlaymodeData::has_readyfile() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapBasePlaymodeData::set_has_readyfile() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapBasePlaymodeData::clear_has_readyfile() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapBasePlaymodeData::clear_readyfile() {
  if (readyfile_ != &::google::protobuf::internal::kEmptyString) {
    readyfile_->clear();
  }
  clear_has_readyfile();
}
inline const ::std::string& MapBasePlaymodeData::readyfile() const {
  return *readyfile_;
}
inline void MapBasePlaymodeData::set_readyfile(const ::std::string& value) {
  set_has_readyfile();
  if (readyfile_ == &::google::protobuf::internal::kEmptyString) {
    readyfile_ = new ::std::string;
  }
  readyfile_->assign(value);
}
inline void MapBasePlaymodeData::set_readyfile(const char* value) {
  set_has_readyfile();
  if (readyfile_ == &::google::protobuf::internal::kEmptyString) {
    readyfile_ = new ::std::string;
  }
  readyfile_->assign(value);
}
inline void MapBasePlaymodeData::set_readyfile(const char* value, size_t size) {
  set_has_readyfile();
  if (readyfile_ == &::google::protobuf::internal::kEmptyString) {
    readyfile_ = new ::std::string;
  }
  readyfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapBasePlaymodeData::mutable_readyfile() {
  set_has_readyfile();
  if (readyfile_ == &::google::protobuf::internal::kEmptyString) {
    readyfile_ = new ::std::string;
  }
  return readyfile_;
}
inline ::std::string* MapBasePlaymodeData::release_readyfile() {
  clear_has_readyfile();
  if (readyfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = readyfile_;
    readyfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapBasePlaymodeData::set_allocated_readyfile(::std::string* readyfile) {
  if (readyfile_ != &::google::protobuf::internal::kEmptyString) {
    delete readyfile_;
  }
  if (readyfile) {
    set_has_readyfile();
    readyfile_ = readyfile;
  } else {
    clear_has_readyfile();
    readyfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float ReadyTime = 11 [default = -1];
inline bool MapBasePlaymodeData::has_readytime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapBasePlaymodeData::set_has_readytime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapBasePlaymodeData::clear_has_readytime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapBasePlaymodeData::clear_readytime() {
  readytime_ = -1;
  clear_has_readytime();
}
inline float MapBasePlaymodeData::readytime() const {
  return readytime_;
}
inline void MapBasePlaymodeData::set_readytime(float value) {
  set_has_readytime();
  readytime_ = value;
}

// optional float ControlTime = 12 [default = -1];
inline bool MapBasePlaymodeData::has_controltime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapBasePlaymodeData::set_has_controltime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapBasePlaymodeData::clear_has_controltime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapBasePlaymodeData::clear_controltime() {
  controltime_ = -1;
  clear_has_controltime();
}
inline float MapBasePlaymodeData::controltime() const {
  return controltime_;
}
inline void MapBasePlaymodeData::set_controltime(float value) {
  set_has_controltime();
  controltime_ = value;
}

// optional float ChangePriTime = 13 [default = -1];
inline bool MapBasePlaymodeData::has_changepritime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapBasePlaymodeData::set_has_changepritime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapBasePlaymodeData::clear_has_changepritime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapBasePlaymodeData::clear_changepritime() {
  changepritime_ = -1;
  clear_has_changepritime();
}
inline float MapBasePlaymodeData::changepritime() const {
  return changepritime_;
}
inline void MapBasePlaymodeData::set_changepritime(float value) {
  set_has_changepritime();
  changepritime_ = value;
}

// -------------------------------------------------------------------

// MapTeamData

// optional string Guard = 1;
inline bool MapTeamData::has_guard() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapTeamData::set_has_guard() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapTeamData::clear_has_guard() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapTeamData::clear_guard() {
  if (guard_ != &::google::protobuf::internal::kEmptyString) {
    guard_->clear();
  }
  clear_has_guard();
}
inline const ::std::string& MapTeamData::guard() const {
  return *guard_;
}
inline void MapTeamData::set_guard(const ::std::string& value) {
  set_has_guard();
  if (guard_ == &::google::protobuf::internal::kEmptyString) {
    guard_ = new ::std::string;
  }
  guard_->assign(value);
}
inline void MapTeamData::set_guard(const char* value) {
  set_has_guard();
  if (guard_ == &::google::protobuf::internal::kEmptyString) {
    guard_ = new ::std::string;
  }
  guard_->assign(value);
}
inline void MapTeamData::set_guard(const char* value, size_t size) {
  set_has_guard();
  if (guard_ == &::google::protobuf::internal::kEmptyString) {
    guard_ = new ::std::string;
  }
  guard_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapTeamData::mutable_guard() {
  set_has_guard();
  if (guard_ == &::google::protobuf::internal::kEmptyString) {
    guard_ = new ::std::string;
  }
  return guard_;
}
inline ::std::string* MapTeamData::release_guard() {
  clear_has_guard();
  if (guard_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guard_;
    guard_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapTeamData::set_allocated_guard(::std::string* guard) {
  if (guard_ != &::google::protobuf::internal::kEmptyString) {
    delete guard_;
  }
  if (guard) {
    set_has_guard();
    guard_ = guard;
  } else {
    clear_has_guard();
    guard_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Pedestal = 2;
inline bool MapTeamData::has_pedestal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapTeamData::set_has_pedestal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapTeamData::clear_has_pedestal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapTeamData::clear_pedestal() {
  if (pedestal_ != &::google::protobuf::internal::kEmptyString) {
    pedestal_->clear();
  }
  clear_has_pedestal();
}
inline const ::std::string& MapTeamData::pedestal() const {
  return *pedestal_;
}
inline void MapTeamData::set_pedestal(const ::std::string& value) {
  set_has_pedestal();
  if (pedestal_ == &::google::protobuf::internal::kEmptyString) {
    pedestal_ = new ::std::string;
  }
  pedestal_->assign(value);
}
inline void MapTeamData::set_pedestal(const char* value) {
  set_has_pedestal();
  if (pedestal_ == &::google::protobuf::internal::kEmptyString) {
    pedestal_ = new ::std::string;
  }
  pedestal_->assign(value);
}
inline void MapTeamData::set_pedestal(const char* value, size_t size) {
  set_has_pedestal();
  if (pedestal_ == &::google::protobuf::internal::kEmptyString) {
    pedestal_ = new ::std::string;
  }
  pedestal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapTeamData::mutable_pedestal() {
  set_has_pedestal();
  if (pedestal_ == &::google::protobuf::internal::kEmptyString) {
    pedestal_ = new ::std::string;
  }
  return pedestal_;
}
inline ::std::string* MapTeamData::release_pedestal() {
  clear_has_pedestal();
  if (pedestal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pedestal_;
    pedestal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapTeamData::set_allocated_pedestal(::std::string* pedestal) {
  if (pedestal_ != &::google::protobuf::internal::kEmptyString) {
    delete pedestal_;
  }
  if (pedestal) {
    set_has_pedestal();
    pedestal_ = pedestal;
  } else {
    clear_has_pedestal();
    pedestal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .MapPRS SpawnPoints = 3;
inline int MapTeamData::spawnpoints_size() const {
  return spawnpoints_.size();
}
inline void MapTeamData::clear_spawnpoints() {
  spawnpoints_.Clear();
}
inline const ::MapPRS& MapTeamData::spawnpoints(int index) const {
  return spawnpoints_.Get(index);
}
inline ::MapPRS* MapTeamData::mutable_spawnpoints(int index) {
  return spawnpoints_.Mutable(index);
}
inline ::MapPRS* MapTeamData::add_spawnpoints() {
  return spawnpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapPRS >&
MapTeamData::spawnpoints() const {
  return spawnpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapPRS >*
MapTeamData::mutable_spawnpoints() {
  return &spawnpoints_;
}

// optional string Lifting = 4;
inline bool MapTeamData::has_lifting() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapTeamData::set_has_lifting() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapTeamData::clear_has_lifting() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapTeamData::clear_lifting() {
  if (lifting_ != &::google::protobuf::internal::kEmptyString) {
    lifting_->clear();
  }
  clear_has_lifting();
}
inline const ::std::string& MapTeamData::lifting() const {
  return *lifting_;
}
inline void MapTeamData::set_lifting(const ::std::string& value) {
  set_has_lifting();
  if (lifting_ == &::google::protobuf::internal::kEmptyString) {
    lifting_ = new ::std::string;
  }
  lifting_->assign(value);
}
inline void MapTeamData::set_lifting(const char* value) {
  set_has_lifting();
  if (lifting_ == &::google::protobuf::internal::kEmptyString) {
    lifting_ = new ::std::string;
  }
  lifting_->assign(value);
}
inline void MapTeamData::set_lifting(const char* value, size_t size) {
  set_has_lifting();
  if (lifting_ == &::google::protobuf::internal::kEmptyString) {
    lifting_ = new ::std::string;
  }
  lifting_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapTeamData::mutable_lifting() {
  set_has_lifting();
  if (lifting_ == &::google::protobuf::internal::kEmptyString) {
    lifting_ = new ::std::string;
  }
  return lifting_;
}
inline ::std::string* MapTeamData::release_lifting() {
  clear_has_lifting();
  if (lifting_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lifting_;
    lifting_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapTeamData::set_allocated_lifting(::std::string* lifting) {
  if (lifting_ != &::google::protobuf::internal::kEmptyString) {
    delete lifting_;
  }
  if (lifting) {
    set_has_lifting();
    lifting_ = lifting;
  } else {
    clear_has_lifting();
    lifting_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 Id = 5 [default = -1];
inline bool MapTeamData::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapTeamData::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapTeamData::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapTeamData::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 MapTeamData::id() const {
  return id_;
}
inline void MapTeamData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .Color4PB Color = 6;
inline bool MapTeamData::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapTeamData::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapTeamData::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapTeamData::clear_color() {
  if (color_ != NULL) color_->::Color4PB::Clear();
  clear_has_color();
}
inline const ::Color4PB& MapTeamData::color() const {
  return color_ != NULL ? *color_ : *default_instance_->color_;
}
inline ::Color4PB* MapTeamData::mutable_color() {
  set_has_color();
  if (color_ == NULL) color_ = new ::Color4PB;
  return color_;
}
inline ::Color4PB* MapTeamData::release_color() {
  clear_has_color();
  ::Color4PB* temp = color_;
  color_ = NULL;
  return temp;
}
inline void MapTeamData::set_allocated_color(::Color4PB* color) {
  delete color_;
  color_ = color;
  if (color) {
    set_has_color();
  } else {
    clear_has_color();
  }
}

// optional .Vector3PB PedestalPosition = 7;
inline bool MapTeamData::has_pedestalposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapTeamData::set_has_pedestalposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapTeamData::clear_has_pedestalposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapTeamData::clear_pedestalposition() {
  if (pedestalposition_ != NULL) pedestalposition_->::Vector3PB::Clear();
  clear_has_pedestalposition();
}
inline const ::Vector3PB& MapTeamData::pedestalposition() const {
  return pedestalposition_ != NULL ? *pedestalposition_ : *default_instance_->pedestalposition_;
}
inline ::Vector3PB* MapTeamData::mutable_pedestalposition() {
  set_has_pedestalposition();
  if (pedestalposition_ == NULL) pedestalposition_ = new ::Vector3PB;
  return pedestalposition_;
}
inline ::Vector3PB* MapTeamData::release_pedestalposition() {
  clear_has_pedestalposition();
  ::Vector3PB* temp = pedestalposition_;
  pedestalposition_ = NULL;
  return temp;
}
inline void MapTeamData::set_allocated_pedestalposition(::Vector3PB* pedestalposition) {
  delete pedestalposition_;
  pedestalposition_ = pedestalposition;
  if (pedestalposition) {
    set_has_pedestalposition();
  } else {
    clear_has_pedestalposition();
  }
}

// -------------------------------------------------------------------

// MapSprayData

// optional string Name = 1;
inline bool MapSprayData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapSprayData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapSprayData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapSprayData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapSprayData::name() const {
  return *name_;
}
inline void MapSprayData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapSprayData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapSprayData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapSprayData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MapSprayData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapSprayData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Vector3PB Position = 2;
inline bool MapSprayData::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapSprayData::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapSprayData::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapSprayData::clear_position() {
  if (position_ != NULL) position_->::Vector3PB::Clear();
  clear_has_position();
}
inline const ::Vector3PB& MapSprayData::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Vector3PB* MapSprayData::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Vector3PB;
  return position_;
}
inline ::Vector3PB* MapSprayData::release_position() {
  clear_has_position();
  ::Vector3PB* temp = position_;
  position_ = NULL;
  return temp;
}
inline void MapSprayData::set_allocated_position(::Vector3PB* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional sint32 Dpi = 3 [default = -1];
inline bool MapSprayData::has_dpi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapSprayData::set_has_dpi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapSprayData::clear_has_dpi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapSprayData::clear_dpi() {
  dpi_ = -1;
  clear_has_dpi();
}
inline ::google::protobuf::int32 MapSprayData::dpi() const {
  return dpi_;
}
inline void MapSprayData::set_dpi(::google::protobuf::int32 value) {
  set_has_dpi();
  dpi_ = value;
}

// optional float Coefficient = 4 [default = -1];
inline bool MapSprayData::has_coefficient() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapSprayData::set_has_coefficient() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapSprayData::clear_has_coefficient() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapSprayData::clear_coefficient() {
  coefficient_ = -1;
  clear_has_coefficient();
}
inline float MapSprayData::coefficient() const {
  return coefficient_;
}
inline void MapSprayData::set_coefficient(float value) {
  set_has_coefficient();
  coefficient_ = value;
}

// -------------------------------------------------------------------

// MapPvpData

// optional .MapBasePlaymodeData BaseData = 1;
inline bool MapPvpData::has_basedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPvpData::set_has_basedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPvpData::clear_has_basedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPvpData::clear_basedata() {
  if (basedata_ != NULL) basedata_->::MapBasePlaymodeData::Clear();
  clear_has_basedata();
}
inline const ::MapBasePlaymodeData& MapPvpData::basedata() const {
  return basedata_ != NULL ? *basedata_ : *default_instance_->basedata_;
}
inline ::MapBasePlaymodeData* MapPvpData::mutable_basedata() {
  set_has_basedata();
  if (basedata_ == NULL) basedata_ = new ::MapBasePlaymodeData;
  return basedata_;
}
inline ::MapBasePlaymodeData* MapPvpData::release_basedata() {
  clear_has_basedata();
  ::MapBasePlaymodeData* temp = basedata_;
  basedata_ = NULL;
  return temp;
}
inline void MapPvpData::set_allocated_basedata(::MapBasePlaymodeData* basedata) {
  delete basedata_;
  basedata_ = basedata;
  if (basedata) {
    set_has_basedata();
  } else {
    clear_has_basedata();
  }
}

// optional string AddHere = 2;
inline bool MapPvpData::has_addhere() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPvpData::set_has_addhere() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPvpData::clear_has_addhere() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPvpData::clear_addhere() {
  if (addhere_ != &::google::protobuf::internal::kEmptyString) {
    addhere_->clear();
  }
  clear_has_addhere();
}
inline const ::std::string& MapPvpData::addhere() const {
  return *addhere_;
}
inline void MapPvpData::set_addhere(const ::std::string& value) {
  set_has_addhere();
  if (addhere_ == &::google::protobuf::internal::kEmptyString) {
    addhere_ = new ::std::string;
  }
  addhere_->assign(value);
}
inline void MapPvpData::set_addhere(const char* value) {
  set_has_addhere();
  if (addhere_ == &::google::protobuf::internal::kEmptyString) {
    addhere_ = new ::std::string;
  }
  addhere_->assign(value);
}
inline void MapPvpData::set_addhere(const char* value, size_t size) {
  set_has_addhere();
  if (addhere_ == &::google::protobuf::internal::kEmptyString) {
    addhere_ = new ::std::string;
  }
  addhere_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapPvpData::mutable_addhere() {
  set_has_addhere();
  if (addhere_ == &::google::protobuf::internal::kEmptyString) {
    addhere_ = new ::std::string;
  }
  return addhere_;
}
inline ::std::string* MapPvpData::release_addhere() {
  clear_has_addhere();
  if (addhere_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addhere_;
    addhere_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapPvpData::set_allocated_addhere(::std::string* addhere) {
  if (addhere_ != &::google::protobuf::internal::kEmptyString) {
    delete addhere_;
  }
  if (addhere) {
    set_has_addhere();
    addhere_ = addhere;
  } else {
    clear_has_addhere();
    addhere_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MapPRS

// optional .Vector3PB Position = 1;
inline bool MapPRS::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPRS::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPRS::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPRS::clear_position() {
  if (position_ != NULL) position_->::Vector3PB::Clear();
  clear_has_position();
}
inline const ::Vector3PB& MapPRS::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::Vector3PB* MapPRS::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::Vector3PB;
  return position_;
}
inline ::Vector3PB* MapPRS::release_position() {
  clear_has_position();
  ::Vector3PB* temp = position_;
  position_ = NULL;
  return temp;
}
inline void MapPRS::set_allocated_position(::Vector3PB* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional .Vector3PB EularRotation = 2;
inline bool MapPRS::has_eularrotation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPRS::set_has_eularrotation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPRS::clear_has_eularrotation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPRS::clear_eularrotation() {
  if (eularrotation_ != NULL) eularrotation_->::Vector3PB::Clear();
  clear_has_eularrotation();
}
inline const ::Vector3PB& MapPRS::eularrotation() const {
  return eularrotation_ != NULL ? *eularrotation_ : *default_instance_->eularrotation_;
}
inline ::Vector3PB* MapPRS::mutable_eularrotation() {
  set_has_eularrotation();
  if (eularrotation_ == NULL) eularrotation_ = new ::Vector3PB;
  return eularrotation_;
}
inline ::Vector3PB* MapPRS::release_eularrotation() {
  clear_has_eularrotation();
  ::Vector3PB* temp = eularrotation_;
  eularrotation_ = NULL;
  return temp;
}
inline void MapPRS::set_allocated_eularrotation(::Vector3PB* eularrotation) {
  delete eularrotation_;
  eularrotation_ = eularrotation;
  if (eularrotation) {
    set_has_eularrotation();
  } else {
    clear_has_eularrotation();
  }
}

// optional .Vector3PB Scale = 3;
inline bool MapPRS::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapPRS::set_has_scale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapPRS::clear_has_scale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapPRS::clear_scale() {
  if (scale_ != NULL) scale_->::Vector3PB::Clear();
  clear_has_scale();
}
inline const ::Vector3PB& MapPRS::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::Vector3PB* MapPRS::mutable_scale() {
  set_has_scale();
  if (scale_ == NULL) scale_ = new ::Vector3PB;
  return scale_;
}
inline ::Vector3PB* MapPRS::release_scale() {
  clear_has_scale();
  ::Vector3PB* temp = scale_;
  scale_ = NULL;
  return temp;
}
inline void MapPRS::set_allocated_scale(::Vector3PB* scale) {
  delete scale_;
  scale_ = scale;
  if (scale) {
    set_has_scale();
  } else {
    clear_has_scale();
  }
}

// -------------------------------------------------------------------

// MapCameraData

// optional string Path = 1;
inline bool MapCameraData::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapCameraData::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapCameraData::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapCameraData::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& MapCameraData::path() const {
  return *path_;
}
inline void MapCameraData::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void MapCameraData::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void MapCameraData::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapCameraData::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* MapCameraData::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapCameraData::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float StartTime = 2 [default = -1];
inline bool MapCameraData::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapCameraData::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapCameraData::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapCameraData::clear_starttime() {
  starttime_ = -1;
  clear_has_starttime();
}
inline float MapCameraData::starttime() const {
  return starttime_;
}
inline void MapCameraData::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
}

// optional float EndTime = 3 [default = -1];
inline bool MapCameraData::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapCameraData::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapCameraData::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapCameraData::clear_endtime() {
  endtime_ = -1;
  clear_has_endtime();
}
inline float MapCameraData::endtime() const {
  return endtime_;
}
inline void MapCameraData::set_endtime(float value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// MapLiftingConfig

// optional float StartTime = 1 [default = -1];
inline bool MapLiftingConfig::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapLiftingConfig::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapLiftingConfig::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapLiftingConfig::clear_starttime() {
  starttime_ = -1;
  clear_has_starttime();
}
inline float MapLiftingConfig::starttime() const {
  return starttime_;
}
inline void MapLiftingConfig::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
}

// optional float Speed = 2 [default = -1];
inline bool MapLiftingConfig::has_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapLiftingConfig::set_has_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapLiftingConfig::clear_has_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapLiftingConfig::clear_speed() {
  speed_ = -1;
  clear_has_speed();
}
inline float MapLiftingConfig::speed() const {
  return speed_;
}
inline void MapLiftingConfig::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// MapPositionGraph

// optional sint32 Id = 1 [default = -1];
inline bool MapPositionGraph::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPositionGraph::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPositionGraph::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPositionGraph::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 MapPositionGraph::id() const {
  return id_;
}
inline void MapPositionGraph::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .Vector3PB Vertices = 2;
inline int MapPositionGraph::vertices_size() const {
  return vertices_.size();
}
inline void MapPositionGraph::clear_vertices() {
  vertices_.Clear();
}
inline const ::Vector3PB& MapPositionGraph::vertices(int index) const {
  return vertices_.Get(index);
}
inline ::Vector3PB* MapPositionGraph::mutable_vertices(int index) {
  return vertices_.Mutable(index);
}
inline ::Vector3PB* MapPositionGraph::add_vertices() {
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Vector3PB >&
MapPositionGraph::vertices() const {
  return vertices_;
}
inline ::google::protobuf::RepeatedPtrField< ::Vector3PB >*
MapPositionGraph::mutable_vertices() {
  return &vertices_;
}

// repeated .Vector2IntPB Edges = 3;
inline int MapPositionGraph::edges_size() const {
  return edges_.size();
}
inline void MapPositionGraph::clear_edges() {
  edges_.Clear();
}
inline const ::Vector2IntPB& MapPositionGraph::edges(int index) const {
  return edges_.Get(index);
}
inline ::Vector2IntPB* MapPositionGraph::mutable_edges(int index) {
  return edges_.Mutable(index);
}
inline ::Vector2IntPB* MapPositionGraph::add_edges() {
  return edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Vector2IntPB >&
MapPositionGraph::edges() const {
  return edges_;
}
inline ::google::protobuf::RepeatedPtrField< ::Vector2IntPB >*
MapPositionGraph::mutable_edges() {
  return &edges_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MapCliRpc_2eproto__INCLUDED
