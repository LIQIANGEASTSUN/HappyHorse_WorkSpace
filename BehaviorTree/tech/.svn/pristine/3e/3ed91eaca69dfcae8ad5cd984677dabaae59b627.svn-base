// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AISvrRpc.proto

#ifndef PROTOBUF_AISvrRpc_2eproto__INCLUDED
#define PROTOBUF_AISvrRpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PublicStruct.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AISvrRpc_2eproto();
void protobuf_AssignDesc_AISvrRpc_2eproto();
void protobuf_ShutdownFile_AISvrRpc_2eproto();

class AIRpcCreateAISceneAsk;
class AIRpcCreateAISceneReply;
class AIUserP;
class AIRpcDeleteAISceneNotify;
class AIRpcLoadUsersNotify;
class AIRpcNoticeAIUserOperNotify;
class AIRpcNoticeSceneInfoNotify;
class AIRpcNoticeUpdateSceneInfoNotify;
class AIUserData;
class AIUserCom;
class AIUserProp;
class AIUserPosCom;
class AIRpcDeleteUserNotify;

// ===================================================================

class AIRpcCreateAISceneAsk : public ::google::protobuf::Message {
 public:
  AIRpcCreateAISceneAsk();
  virtual ~AIRpcCreateAISceneAsk();

  AIRpcCreateAISceneAsk(const AIRpcCreateAISceneAsk& from);

  inline AIRpcCreateAISceneAsk& operator=(const AIRpcCreateAISceneAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcCreateAISceneAsk& default_instance();

  void Swap(AIRpcCreateAISceneAsk* other);

  // implements Message ----------------------------------------------

  AIRpcCreateAISceneAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcCreateAISceneAsk& from);
  void MergeFrom(const AIRpcCreateAISceneAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AIUserP Members = 1;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 1;
  inline const ::AIUserP& members(int index) const;
  inline ::AIUserP* mutable_members(int index);
  inline ::AIUserP* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::AIUserP >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::AIUserP >*
      mutable_members();

  // optional sint64 RoomID = 2 [default = -1];
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 2;
  inline ::google::protobuf::int64 roomid() const;
  inline void set_roomid(::google::protobuf::int64 value);

  // optional sint32 SceneConfId = 3 [default = 0];
  inline bool has_sceneconfid() const;
  inline void clear_sceneconfid();
  static const int kSceneConfIdFieldNumber = 3;
  inline ::google::protobuf::int32 sceneconfid() const;
  inline void set_sceneconfid(::google::protobuf::int32 value);

  // optional sint32 SceneID = 4 [default = 1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIDFieldNumber = 4;
  inline ::google::protobuf::int32 sceneid() const;
  inline void set_sceneid(::google::protobuf::int32 value);

  // optional string NodeName = 6;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 6;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // @@protoc_insertion_point(class_scope:AIRpcCreateAISceneAsk)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_sceneconfid();
  inline void clear_has_sceneconfid();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_nodename();
  inline void clear_has_nodename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AIUserP > members_;
  ::google::protobuf::int64 roomid_;
  ::google::protobuf::int32 sceneconfid_;
  ::google::protobuf::int32 sceneid_;
  ::std::string* nodename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcCreateAISceneAsk* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcCreateAISceneReply : public ::google::protobuf::Message {
 public:
  AIRpcCreateAISceneReply();
  virtual ~AIRpcCreateAISceneReply();

  AIRpcCreateAISceneReply(const AIRpcCreateAISceneReply& from);

  inline AIRpcCreateAISceneReply& operator=(const AIRpcCreateAISceneReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcCreateAISceneReply& default_instance();

  void Swap(AIRpcCreateAISceneReply* other);

  // implements Message ----------------------------------------------

  AIRpcCreateAISceneReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcCreateAISceneReply& from);
  void MergeFrom(const AIRpcCreateAISceneReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 2 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AIRpcCreateAISceneReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcCreateAISceneReply* default_instance_;
};
// -------------------------------------------------------------------

class AIUserP : public ::google::protobuf::Message {
 public:
  AIUserP();
  virtual ~AIUserP();

  AIUserP(const AIUserP& from);

  inline AIUserP& operator=(const AIUserP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIUserP& default_instance();

  void Swap(AIUserP* other);

  // implements Message ----------------------------------------------

  AIUserP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIUserP& from);
  void MergeFrom(const AIUserP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 Uid = 6 [default = -1];
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional sint32 HreoID = 7 [default = -1];
  inline bool has_hreoid() const;
  inline void clear_hreoid();
  static const int kHreoIDFieldNumber = 7;
  inline ::google::protobuf::int32 hreoid() const;
  inline void set_hreoid(::google::protobuf::int32 value);

  // optional sint32 IsMonster = 8 [default = -1];
  inline bool has_ismonster() const;
  inline void clear_ismonster();
  static const int kIsMonsterFieldNumber = 8;
  inline ::google::protobuf::int32 ismonster() const;
  inline void set_ismonster(::google::protobuf::int32 value);

  // optional string Key = 9;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 9;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional sint32 TeamId = 10 [default = 0];
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamIdFieldNumber = 10;
  inline ::google::protobuf::int32 teamid() const;
  inline void set_teamid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AIUserP)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_hreoid();
  inline void clear_has_hreoid();
  inline void set_has_ismonster();
  inline void clear_has_ismonster();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_teamid();
  inline void clear_has_teamid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::google::protobuf::int32 hreoid_;
  ::google::protobuf::int32 ismonster_;
  ::std::string* key_;
  ::google::protobuf::int32 teamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIUserP* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcDeleteAISceneNotify : public ::google::protobuf::Message {
 public:
  AIRpcDeleteAISceneNotify();
  virtual ~AIRpcDeleteAISceneNotify();

  AIRpcDeleteAISceneNotify(const AIRpcDeleteAISceneNotify& from);

  inline AIRpcDeleteAISceneNotify& operator=(const AIRpcDeleteAISceneNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcDeleteAISceneNotify& default_instance();

  void Swap(AIRpcDeleteAISceneNotify* other);

  // implements Message ----------------------------------------------

  AIRpcDeleteAISceneNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcDeleteAISceneNotify& from);
  void MergeFrom(const AIRpcDeleteAISceneNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 RoomID = 1 [default = -1];
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIDFieldNumber = 1;
  inline ::google::protobuf::int64 roomid() const;
  inline void set_roomid(::google::protobuf::int64 value);

  // optional string NodeName = 2;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodeNameFieldNumber = 2;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // optional sint32 SceneID = 3 [default = 1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIDFieldNumber = 3;
  inline ::google::protobuf::int32 sceneid() const;
  inline void set_sceneid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AIRpcDeleteAISceneNotify)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_nodename();
  inline void clear_has_nodename();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 roomid_;
  ::std::string* nodename_;
  ::google::protobuf::int32 sceneid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcDeleteAISceneNotify* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcLoadUsersNotify : public ::google::protobuf::Message {
 public:
  AIRpcLoadUsersNotify();
  virtual ~AIRpcLoadUsersNotify();

  AIRpcLoadUsersNotify(const AIRpcLoadUsersNotify& from);

  inline AIRpcLoadUsersNotify& operator=(const AIRpcLoadUsersNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcLoadUsersNotify& default_instance();

  void Swap(AIRpcLoadUsersNotify* other);

  // implements Message ----------------------------------------------

  AIRpcLoadUsersNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcLoadUsersNotify& from);
  void MergeFrom(const AIRpcLoadUsersNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes Userinfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 1;
  inline const ::std::string& userinfo() const;
  inline void set_userinfo(const ::std::string& value);
  inline void set_userinfo(const char* value);
  inline void set_userinfo(const void* value, size_t size);
  inline ::std::string* mutable_userinfo();
  inline ::std::string* release_userinfo();
  inline void set_allocated_userinfo(::std::string* userinfo);

  // optional sint64 SceneId = 2 [default = -1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIdFieldNumber = 2;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AIRpcLoadUsersNotify)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userinfo_;
  ::google::protobuf::int64 sceneid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcLoadUsersNotify* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcNoticeAIUserOperNotify : public ::google::protobuf::Message {
 public:
  AIRpcNoticeAIUserOperNotify();
  virtual ~AIRpcNoticeAIUserOperNotify();

  AIRpcNoticeAIUserOperNotify(const AIRpcNoticeAIUserOperNotify& from);

  inline AIRpcNoticeAIUserOperNotify& operator=(const AIRpcNoticeAIUserOperNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcNoticeAIUserOperNotify& default_instance();

  void Swap(AIRpcNoticeAIUserOperNotify* other);

  // implements Message ----------------------------------------------

  AIRpcNoticeAIUserOperNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcNoticeAIUserOperNotify& from);
  void MergeFrom(const AIRpcNoticeAIUserOperNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 OperType = 1 [default = -1];
  inline bool has_opertype() const;
  inline void clear_opertype();
  static const int kOperTypeFieldNumber = 1;
  inline ::google::protobuf::int32 opertype() const;
  inline void set_opertype(::google::protobuf::int32 value);

  // optional sint64 UserId = 2 [default = -1];
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);

  // repeated bytes MsgInfo = 3;
  inline int msginfo_size() const;
  inline void clear_msginfo();
  static const int kMsgInfoFieldNumber = 3;
  inline const ::std::string& msginfo(int index) const;
  inline ::std::string* mutable_msginfo(int index);
  inline void set_msginfo(int index, const ::std::string& value);
  inline void set_msginfo(int index, const char* value);
  inline void set_msginfo(int index, const void* value, size_t size);
  inline ::std::string* add_msginfo();
  inline void add_msginfo(const ::std::string& value);
  inline void add_msginfo(const char* value);
  inline void add_msginfo(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& msginfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msginfo();

  // optional sint64 SceneId = 4 [default = -1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIdFieldNumber = 4;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AIRpcNoticeAIUserOperNotify)
 private:
  inline void set_has_opertype();
  inline void clear_has_opertype();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 userid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> msginfo_;
  ::google::protobuf::int64 sceneid_;
  ::google::protobuf::int32 opertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcNoticeAIUserOperNotify* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcNoticeSceneInfoNotify : public ::google::protobuf::Message {
 public:
  AIRpcNoticeSceneInfoNotify();
  virtual ~AIRpcNoticeSceneInfoNotify();

  AIRpcNoticeSceneInfoNotify(const AIRpcNoticeSceneInfoNotify& from);

  inline AIRpcNoticeSceneInfoNotify& operator=(const AIRpcNoticeSceneInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcNoticeSceneInfoNotify& default_instance();

  void Swap(AIRpcNoticeSceneInfoNotify* other);

  // implements Message ----------------------------------------------

  AIRpcNoticeSceneInfoNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcNoticeSceneInfoNotify& from);
  void MergeFrom(const AIRpcNoticeSceneInfoNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 SceneId = 1 [default = -1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIdFieldNumber = 1;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // optional bytes SceneInfo = 2;
  inline bool has_sceneinfo() const;
  inline void clear_sceneinfo();
  static const int kSceneInfoFieldNumber = 2;
  inline const ::std::string& sceneinfo() const;
  inline void set_sceneinfo(const ::std::string& value);
  inline void set_sceneinfo(const char* value);
  inline void set_sceneinfo(const void* value, size_t size);
  inline ::std::string* mutable_sceneinfo();
  inline ::std::string* release_sceneinfo();
  inline void set_allocated_sceneinfo(::std::string* sceneinfo);

  // @@protoc_insertion_point(class_scope:AIRpcNoticeSceneInfoNotify)
 private:
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_sceneinfo();
  inline void clear_has_sceneinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 sceneid_;
  ::std::string* sceneinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcNoticeSceneInfoNotify* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcNoticeUpdateSceneInfoNotify : public ::google::protobuf::Message {
 public:
  AIRpcNoticeUpdateSceneInfoNotify();
  virtual ~AIRpcNoticeUpdateSceneInfoNotify();

  AIRpcNoticeUpdateSceneInfoNotify(const AIRpcNoticeUpdateSceneInfoNotify& from);

  inline AIRpcNoticeUpdateSceneInfoNotify& operator=(const AIRpcNoticeUpdateSceneInfoNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcNoticeUpdateSceneInfoNotify& default_instance();

  void Swap(AIRpcNoticeUpdateSceneInfoNotify* other);

  // implements Message ----------------------------------------------

  AIRpcNoticeUpdateSceneInfoNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcNoticeUpdateSceneInfoNotify& from);
  void MergeFrom(const AIRpcNoticeUpdateSceneInfoNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 SceneId = 1 [default = -1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIdFieldNumber = 1;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // repeated .AIUserData Userinfo = 3;
  inline int userinfo_size() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 3;
  inline const ::AIUserData& userinfo(int index) const;
  inline ::AIUserData* mutable_userinfo(int index);
  inline ::AIUserData* add_userinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::AIUserData >&
      userinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::AIUserData >*
      mutable_userinfo();

  // repeated bytes Sprayinfo = 4;
  inline int sprayinfo_size() const;
  inline void clear_sprayinfo();
  static const int kSprayinfoFieldNumber = 4;
  inline const ::std::string& sprayinfo(int index) const;
  inline ::std::string* mutable_sprayinfo(int index);
  inline void set_sprayinfo(int index, const ::std::string& value);
  inline void set_sprayinfo(int index, const char* value);
  inline void set_sprayinfo(int index, const void* value, size_t size);
  inline ::std::string* add_sprayinfo();
  inline void add_sprayinfo(const ::std::string& value);
  inline void add_sprayinfo(const char* value);
  inline void add_sprayinfo(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sprayinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sprayinfo();

  // optional sint64 Sendtime = 5 [default = -1];
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendtimeFieldNumber = 5;
  inline ::google::protobuf::int64 sendtime() const;
  inline void set_sendtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AIRpcNoticeUpdateSceneInfoNotify)
 private:
  inline void set_has_sceneid();
  inline void clear_has_sceneid();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 sceneid_;
  ::google::protobuf::RepeatedPtrField< ::AIUserData > userinfo_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sprayinfo_;
  ::google::protobuf::int64 sendtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcNoticeUpdateSceneInfoNotify* default_instance_;
};
// -------------------------------------------------------------------

class AIUserData : public ::google::protobuf::Message {
 public:
  AIUserData();
  virtual ~AIUserData();

  AIUserData(const AIUserData& from);

  inline AIUserData& operator=(const AIUserData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIUserData& default_instance();

  void Swap(AIUserData* other);

  // implements Message ----------------------------------------------

  AIUserData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIUserData& from);
  void MergeFrom(const AIUserData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AIUserCom Usercom = 3;
  inline bool has_usercom() const;
  inline void clear_usercom();
  static const int kUsercomFieldNumber = 3;
  inline const ::AIUserCom& usercom() const;
  inline ::AIUserCom* mutable_usercom();
  inline ::AIUserCom* release_usercom();
  inline void set_allocated_usercom(::AIUserCom* usercom);

  // optional .AIUserPosCom Userposinfo = 4;
  inline bool has_userposinfo() const;
  inline void clear_userposinfo();
  static const int kUserposinfoFieldNumber = 4;
  inline const ::AIUserPosCom& userposinfo() const;
  inline ::AIUserPosCom* mutable_userposinfo();
  inline ::AIUserPosCom* release_userposinfo();
  inline void set_allocated_userposinfo(::AIUserPosCom* userposinfo);

  // optional .AIUserProp Userprop = 5;
  inline bool has_userprop() const;
  inline void clear_userprop();
  static const int kUserpropFieldNumber = 5;
  inline const ::AIUserProp& userprop() const;
  inline ::AIUserProp* mutable_userprop();
  inline ::AIUserProp* release_userprop();
  inline void set_allocated_userprop(::AIUserProp* userprop);

  // repeated bytes UseskillRet = 6;
  inline int useskillret_size() const;
  inline void clear_useskillret();
  static const int kUseskillRetFieldNumber = 6;
  inline const ::std::string& useskillret(int index) const;
  inline ::std::string* mutable_useskillret(int index);
  inline void set_useskillret(int index, const ::std::string& value);
  inline void set_useskillret(int index, const char* value);
  inline void set_useskillret(int index, const void* value, size_t size);
  inline ::std::string* add_useskillret();
  inline void add_useskillret(const ::std::string& value);
  inline void add_useskillret(const char* value);
  inline void add_useskillret(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& useskillret() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_useskillret();

  // repeated bytes ShootRet = 7;
  inline int shootret_size() const;
  inline void clear_shootret();
  static const int kShootRetFieldNumber = 7;
  inline const ::std::string& shootret(int index) const;
  inline ::std::string* mutable_shootret(int index);
  inline void set_shootret(int index, const ::std::string& value);
  inline void set_shootret(int index, const char* value);
  inline void set_shootret(int index, const void* value, size_t size);
  inline ::std::string* add_shootret();
  inline void add_shootret(const ::std::string& value);
  inline void add_shootret(const char* value);
  inline void add_shootret(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& shootret() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_shootret();

  // @@protoc_insertion_point(class_scope:AIUserData)
 private:
  inline void set_has_usercom();
  inline void clear_has_usercom();
  inline void set_has_userposinfo();
  inline void clear_has_userposinfo();
  inline void set_has_userprop();
  inline void clear_has_userprop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::AIUserCom* usercom_;
  ::AIUserPosCom* userposinfo_;
  ::AIUserProp* userprop_;
  ::google::protobuf::RepeatedPtrField< ::std::string> useskillret_;
  ::google::protobuf::RepeatedPtrField< ::std::string> shootret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIUserData* default_instance_;
};
// -------------------------------------------------------------------

class AIUserCom : public ::google::protobuf::Message {
 public:
  AIUserCom();
  virtual ~AIUserCom();

  AIUserCom(const AIUserCom& from);

  inline AIUserCom& operator=(const AIUserCom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIUserCom& default_instance();

  void Swap(AIUserCom* other);

  // implements Message ----------------------------------------------

  AIUserCom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIUserCom& from);
  void MergeFrom(const AIUserCom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 Uid = 1 [default = -1];
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional bool Dead = 2 [default = false];
  inline bool has_dead() const;
  inline void clear_dead();
  static const int kDeadFieldNumber = 2;
  inline bool dead() const;
  inline void set_dead(bool value);

  // optional .Vector3PB Revivepos = 3;
  inline bool has_revivepos() const;
  inline void clear_revivepos();
  static const int kReviveposFieldNumber = 3;
  inline const ::Vector3PB& revivepos() const;
  inline ::Vector3PB* mutable_revivepos();
  inline ::Vector3PB* release_revivepos();
  inline void set_allocated_revivepos(::Vector3PB* revivepos);

  // optional .Vector3PB FaceDir = 4;
  inline bool has_facedir() const;
  inline void clear_facedir();
  static const int kFaceDirFieldNumber = 4;
  inline const ::Vector3PB& facedir() const;
  inline ::Vector3PB* mutable_facedir();
  inline ::Vector3PB* release_facedir();
  inline void set_allocated_facedir(::Vector3PB* facedir);

  // @@protoc_insertion_point(class_scope:AIUserCom)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_dead();
  inline void clear_has_dead();
  inline void set_has_revivepos();
  inline void clear_has_revivepos();
  inline void set_has_facedir();
  inline void clear_has_facedir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::Vector3PB* revivepos_;
  ::Vector3PB* facedir_;
  bool dead_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIUserCom* default_instance_;
};
// -------------------------------------------------------------------

class AIUserProp : public ::google::protobuf::Message {
 public:
  AIUserProp();
  virtual ~AIUserProp();

  AIUserProp(const AIUserProp& from);

  inline AIUserProp& operator=(const AIUserProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIUserProp& default_instance();

  void Swap(AIUserProp* other);

  // implements Message ----------------------------------------------

  AIUserProp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIUserProp& from);
  void MergeFrom(const AIUserProp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Hp = 1 [default = -1];
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 1;
  inline float hp() const;
  inline void set_hp(float value);

  // optional float Energy = 2 [default = -1];
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 2;
  inline float energy() const;
  inline void set_energy(float value);

  // @@protoc_insertion_point(class_scope:AIUserProp)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_energy();
  inline void clear_has_energy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float hp_;
  float energy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIUserProp* default_instance_;
};
// -------------------------------------------------------------------

class AIUserPosCom : public ::google::protobuf::Message {
 public:
  AIUserPosCom();
  virtual ~AIUserPosCom();

  AIUserPosCom(const AIUserPosCom& from);

  inline AIUserPosCom& operator=(const AIUserPosCom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIUserPosCom& default_instance();

  void Swap(AIUserPosCom* other);

  // implements Message ----------------------------------------------

  AIUserPosCom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIUserPosCom& from);
  void MergeFrom(const AIUserPosCom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool Bmoving = 1 [default = false];
  inline bool has_bmoving() const;
  inline void clear_bmoving();
  static const int kBmovingFieldNumber = 1;
  inline bool bmoving() const;
  inline void set_bmoving(bool value);

  // optional .Vector3PB Footray = 2;
  inline bool has_footray() const;
  inline void clear_footray();
  static const int kFootrayFieldNumber = 2;
  inline const ::Vector3PB& footray() const;
  inline ::Vector3PB* mutable_footray();
  inline ::Vector3PB* release_footray();
  inline void set_allocated_footray(::Vector3PB* footray);

  // optional .Vector3PB Rockdir = 3;
  inline bool has_rockdir() const;
  inline void clear_rockdir();
  static const int kRockdirFieldNumber = 3;
  inline const ::Vector3PB& rockdir() const;
  inline ::Vector3PB* mutable_rockdir();
  inline ::Vector3PB* release_rockdir();
  inline void set_allocated_rockdir(::Vector3PB* rockdir);

  // optional .Vector3PB Movedir = 4;
  inline bool has_movedir() const;
  inline void clear_movedir();
  static const int kMovedirFieldNumber = 4;
  inline const ::Vector3PB& movedir() const;
  inline ::Vector3PB* mutable_movedir();
  inline ::Vector3PB* release_movedir();
  inline void set_allocated_movedir(::Vector3PB* movedir);

  // optional .Vector3PB Pos = 5;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline const ::Vector3PB& pos() const;
  inline ::Vector3PB* mutable_pos();
  inline ::Vector3PB* release_pos();
  inline void set_allocated_pos(::Vector3PB* pos);

  // @@protoc_insertion_point(class_scope:AIUserPosCom)
 private:
  inline void set_has_bmoving();
  inline void clear_has_bmoving();
  inline void set_has_footray();
  inline void clear_has_footray();
  inline void set_has_rockdir();
  inline void clear_has_rockdir();
  inline void set_has_movedir();
  inline void clear_has_movedir();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3PB* footray_;
  ::Vector3PB* rockdir_;
  ::Vector3PB* movedir_;
  ::Vector3PB* pos_;
  bool bmoving_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIUserPosCom* default_instance_;
};
// -------------------------------------------------------------------

class AIRpcDeleteUserNotify : public ::google::protobuf::Message {
 public:
  AIRpcDeleteUserNotify();
  virtual ~AIRpcDeleteUserNotify();

  AIRpcDeleteUserNotify(const AIRpcDeleteUserNotify& from);

  inline AIRpcDeleteUserNotify& operator=(const AIRpcDeleteUserNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AIRpcDeleteUserNotify& default_instance();

  void Swap(AIRpcDeleteUserNotify* other);

  // implements Message ----------------------------------------------

  AIRpcDeleteUserNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AIRpcDeleteUserNotify& from);
  void MergeFrom(const AIRpcDeleteUserNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 Uid = 1 [default = -1];
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int64 uid() const;
  inline void set_uid(::google::protobuf::int64 value);

  // optional sint64 SceneId = 2 [default = -1];
  inline bool has_sceneid() const;
  inline void clear_sceneid();
  static const int kSceneIdFieldNumber = 2;
  inline ::google::protobuf::int64 sceneid() const;
  inline void set_sceneid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AIRpcDeleteUserNotify)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_sceneid();
  inline void clear_has_sceneid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 uid_;
  ::google::protobuf::int64 sceneid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_AISvrRpc_2eproto();
  friend void protobuf_AssignDesc_AISvrRpc_2eproto();
  friend void protobuf_ShutdownFile_AISvrRpc_2eproto();

  void InitAsDefaultInstance();
  static AIRpcDeleteUserNotify* default_instance_;
};
// ===================================================================


// ===================================================================

// AIRpcCreateAISceneAsk

// repeated .AIUserP Members = 1;
inline int AIRpcCreateAISceneAsk::members_size() const {
  return members_.size();
}
inline void AIRpcCreateAISceneAsk::clear_members() {
  members_.Clear();
}
inline const ::AIUserP& AIRpcCreateAISceneAsk::members(int index) const {
  return members_.Get(index);
}
inline ::AIUserP* AIRpcCreateAISceneAsk::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::AIUserP* AIRpcCreateAISceneAsk::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AIUserP >&
AIRpcCreateAISceneAsk::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::AIUserP >*
AIRpcCreateAISceneAsk::mutable_members() {
  return &members_;
}

// optional sint64 RoomID = 2 [default = -1];
inline bool AIRpcCreateAISceneAsk::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIRpcCreateAISceneAsk::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIRpcCreateAISceneAsk::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIRpcCreateAISceneAsk::clear_roomid() {
  roomid_ = GOOGLE_LONGLONG(-1);
  clear_has_roomid();
}
inline ::google::protobuf::int64 AIRpcCreateAISceneAsk::roomid() const {
  return roomid_;
}
inline void AIRpcCreateAISceneAsk::set_roomid(::google::protobuf::int64 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional sint32 SceneConfId = 3 [default = 0];
inline bool AIRpcCreateAISceneAsk::has_sceneconfid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIRpcCreateAISceneAsk::set_has_sceneconfid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIRpcCreateAISceneAsk::clear_has_sceneconfid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIRpcCreateAISceneAsk::clear_sceneconfid() {
  sceneconfid_ = 0;
  clear_has_sceneconfid();
}
inline ::google::protobuf::int32 AIRpcCreateAISceneAsk::sceneconfid() const {
  return sceneconfid_;
}
inline void AIRpcCreateAISceneAsk::set_sceneconfid(::google::protobuf::int32 value) {
  set_has_sceneconfid();
  sceneconfid_ = value;
}

// optional sint32 SceneID = 4 [default = 1];
inline bool AIRpcCreateAISceneAsk::has_sceneid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIRpcCreateAISceneAsk::set_has_sceneid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIRpcCreateAISceneAsk::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIRpcCreateAISceneAsk::clear_sceneid() {
  sceneid_ = 1;
  clear_has_sceneid();
}
inline ::google::protobuf::int32 AIRpcCreateAISceneAsk::sceneid() const {
  return sceneid_;
}
inline void AIRpcCreateAISceneAsk::set_sceneid(::google::protobuf::int32 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// optional string NodeName = 6;
inline bool AIRpcCreateAISceneAsk::has_nodename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AIRpcCreateAISceneAsk::set_has_nodename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AIRpcCreateAISceneAsk::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AIRpcCreateAISceneAsk::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& AIRpcCreateAISceneAsk::nodename() const {
  return *nodename_;
}
inline void AIRpcCreateAISceneAsk::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void AIRpcCreateAISceneAsk::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void AIRpcCreateAISceneAsk::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIRpcCreateAISceneAsk::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  return nodename_;
}
inline ::std::string* AIRpcCreateAISceneAsk::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AIRpcCreateAISceneAsk::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AIRpcCreateAISceneReply

// optional sint32 Result = 2 [default = -9999];
inline bool AIRpcCreateAISceneReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcCreateAISceneReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcCreateAISceneReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcCreateAISceneReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 AIRpcCreateAISceneReply::result() const {
  return result_;
}
inline void AIRpcCreateAISceneReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// AIUserP

// optional sint64 Uid = 6 [default = -1];
inline bool AIUserP::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIUserP::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIUserP::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIUserP::clear_uid() {
  uid_ = GOOGLE_LONGLONG(-1);
  clear_has_uid();
}
inline ::google::protobuf::int64 AIUserP::uid() const {
  return uid_;
}
inline void AIUserP::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional sint32 HreoID = 7 [default = -1];
inline bool AIUserP::has_hreoid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIUserP::set_has_hreoid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIUserP::clear_has_hreoid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIUserP::clear_hreoid() {
  hreoid_ = -1;
  clear_has_hreoid();
}
inline ::google::protobuf::int32 AIUserP::hreoid() const {
  return hreoid_;
}
inline void AIUserP::set_hreoid(::google::protobuf::int32 value) {
  set_has_hreoid();
  hreoid_ = value;
}

// optional sint32 IsMonster = 8 [default = -1];
inline bool AIUserP::has_ismonster() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIUserP::set_has_ismonster() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIUserP::clear_has_ismonster() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIUserP::clear_ismonster() {
  ismonster_ = -1;
  clear_has_ismonster();
}
inline ::google::protobuf::int32 AIUserP::ismonster() const {
  return ismonster_;
}
inline void AIUserP::set_ismonster(::google::protobuf::int32 value) {
  set_has_ismonster();
  ismonster_ = value;
}

// optional string Key = 9;
inline bool AIUserP::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIUserP::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIUserP::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIUserP::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& AIUserP::key() const {
  return *key_;
}
inline void AIUserP::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AIUserP::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void AIUserP::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIUserP::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* AIUserP::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AIUserP::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 TeamId = 10 [default = 0];
inline bool AIUserP::has_teamid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AIUserP::set_has_teamid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AIUserP::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AIUserP::clear_teamid() {
  teamid_ = 0;
  clear_has_teamid();
}
inline ::google::protobuf::int32 AIUserP::teamid() const {
  return teamid_;
}
inline void AIUserP::set_teamid(::google::protobuf::int32 value) {
  set_has_teamid();
  teamid_ = value;
}

// -------------------------------------------------------------------

// AIRpcDeleteAISceneNotify

// optional sint64 RoomID = 1 [default = -1];
inline bool AIRpcDeleteAISceneNotify::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcDeleteAISceneNotify::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcDeleteAISceneNotify::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcDeleteAISceneNotify::clear_roomid() {
  roomid_ = GOOGLE_LONGLONG(-1);
  clear_has_roomid();
}
inline ::google::protobuf::int64 AIRpcDeleteAISceneNotify::roomid() const {
  return roomid_;
}
inline void AIRpcDeleteAISceneNotify::set_roomid(::google::protobuf::int64 value) {
  set_has_roomid();
  roomid_ = value;
}

// optional string NodeName = 2;
inline bool AIRpcDeleteAISceneNotify::has_nodename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIRpcDeleteAISceneNotify::set_has_nodename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIRpcDeleteAISceneNotify::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIRpcDeleteAISceneNotify::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& AIRpcDeleteAISceneNotify::nodename() const {
  return *nodename_;
}
inline void AIRpcDeleteAISceneNotify::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void AIRpcDeleteAISceneNotify::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
}
inline void AIRpcDeleteAISceneNotify::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIRpcDeleteAISceneNotify::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    nodename_ = new ::std::string;
  }
  return nodename_;
}
inline ::std::string* AIRpcDeleteAISceneNotify::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AIRpcDeleteAISceneNotify::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::kEmptyString) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 SceneID = 3 [default = 1];
inline bool AIRpcDeleteAISceneNotify::has_sceneid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIRpcDeleteAISceneNotify::set_has_sceneid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIRpcDeleteAISceneNotify::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIRpcDeleteAISceneNotify::clear_sceneid() {
  sceneid_ = 1;
  clear_has_sceneid();
}
inline ::google::protobuf::int32 AIRpcDeleteAISceneNotify::sceneid() const {
  return sceneid_;
}
inline void AIRpcDeleteAISceneNotify::set_sceneid(::google::protobuf::int32 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// -------------------------------------------------------------------

// AIRpcLoadUsersNotify

// optional bytes Userinfo = 1;
inline bool AIRpcLoadUsersNotify::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcLoadUsersNotify::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcLoadUsersNotify::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcLoadUsersNotify::clear_userinfo() {
  if (userinfo_ != &::google::protobuf::internal::kEmptyString) {
    userinfo_->clear();
  }
  clear_has_userinfo();
}
inline const ::std::string& AIRpcLoadUsersNotify::userinfo() const {
  return *userinfo_;
}
inline void AIRpcLoadUsersNotify::set_userinfo(const ::std::string& value) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(value);
}
inline void AIRpcLoadUsersNotify::set_userinfo(const char* value) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(value);
}
inline void AIRpcLoadUsersNotify::set_userinfo(const void* value, size_t size) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIRpcLoadUsersNotify::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  return userinfo_;
}
inline ::std::string* AIRpcLoadUsersNotify::release_userinfo() {
  clear_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userinfo_;
    userinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AIRpcLoadUsersNotify::set_allocated_userinfo(::std::string* userinfo) {
  if (userinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete userinfo_;
  }
  if (userinfo) {
    set_has_userinfo();
    userinfo_ = userinfo;
  } else {
    clear_has_userinfo();
    userinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint64 SceneId = 2 [default = -1];
inline bool AIRpcLoadUsersNotify::has_sceneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIRpcLoadUsersNotify::set_has_sceneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIRpcLoadUsersNotify::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIRpcLoadUsersNotify::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(-1);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 AIRpcLoadUsersNotify::sceneid() const {
  return sceneid_;
}
inline void AIRpcLoadUsersNotify::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// -------------------------------------------------------------------

// AIRpcNoticeAIUserOperNotify

// optional sint32 OperType = 1 [default = -1];
inline bool AIRpcNoticeAIUserOperNotify::has_opertype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcNoticeAIUserOperNotify::set_has_opertype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcNoticeAIUserOperNotify::clear_has_opertype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcNoticeAIUserOperNotify::clear_opertype() {
  opertype_ = -1;
  clear_has_opertype();
}
inline ::google::protobuf::int32 AIRpcNoticeAIUserOperNotify::opertype() const {
  return opertype_;
}
inline void AIRpcNoticeAIUserOperNotify::set_opertype(::google::protobuf::int32 value) {
  set_has_opertype();
  opertype_ = value;
}

// optional sint64 UserId = 2 [default = -1];
inline bool AIRpcNoticeAIUserOperNotify::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIRpcNoticeAIUserOperNotify::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIRpcNoticeAIUserOperNotify::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIRpcNoticeAIUserOperNotify::clear_userid() {
  userid_ = GOOGLE_LONGLONG(-1);
  clear_has_userid();
}
inline ::google::protobuf::int64 AIRpcNoticeAIUserOperNotify::userid() const {
  return userid_;
}
inline void AIRpcNoticeAIUserOperNotify::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// repeated bytes MsgInfo = 3;
inline int AIRpcNoticeAIUserOperNotify::msginfo_size() const {
  return msginfo_.size();
}
inline void AIRpcNoticeAIUserOperNotify::clear_msginfo() {
  msginfo_.Clear();
}
inline const ::std::string& AIRpcNoticeAIUserOperNotify::msginfo(int index) const {
  return msginfo_.Get(index);
}
inline ::std::string* AIRpcNoticeAIUserOperNotify::mutable_msginfo(int index) {
  return msginfo_.Mutable(index);
}
inline void AIRpcNoticeAIUserOperNotify::set_msginfo(int index, const ::std::string& value) {
  msginfo_.Mutable(index)->assign(value);
}
inline void AIRpcNoticeAIUserOperNotify::set_msginfo(int index, const char* value) {
  msginfo_.Mutable(index)->assign(value);
}
inline void AIRpcNoticeAIUserOperNotify::set_msginfo(int index, const void* value, size_t size) {
  msginfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIRpcNoticeAIUserOperNotify::add_msginfo() {
  return msginfo_.Add();
}
inline void AIRpcNoticeAIUserOperNotify::add_msginfo(const ::std::string& value) {
  msginfo_.Add()->assign(value);
}
inline void AIRpcNoticeAIUserOperNotify::add_msginfo(const char* value) {
  msginfo_.Add()->assign(value);
}
inline void AIRpcNoticeAIUserOperNotify::add_msginfo(const void* value, size_t size) {
  msginfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIRpcNoticeAIUserOperNotify::msginfo() const {
  return msginfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIRpcNoticeAIUserOperNotify::mutable_msginfo() {
  return &msginfo_;
}

// optional sint64 SceneId = 4 [default = -1];
inline bool AIRpcNoticeAIUserOperNotify::has_sceneid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIRpcNoticeAIUserOperNotify::set_has_sceneid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIRpcNoticeAIUserOperNotify::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIRpcNoticeAIUserOperNotify::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(-1);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 AIRpcNoticeAIUserOperNotify::sceneid() const {
  return sceneid_;
}
inline void AIRpcNoticeAIUserOperNotify::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// -------------------------------------------------------------------

// AIRpcNoticeSceneInfoNotify

// optional sint64 SceneId = 1 [default = -1];
inline bool AIRpcNoticeSceneInfoNotify::has_sceneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcNoticeSceneInfoNotify::set_has_sceneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcNoticeSceneInfoNotify::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcNoticeSceneInfoNotify::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(-1);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 AIRpcNoticeSceneInfoNotify::sceneid() const {
  return sceneid_;
}
inline void AIRpcNoticeSceneInfoNotify::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// optional bytes SceneInfo = 2;
inline bool AIRpcNoticeSceneInfoNotify::has_sceneinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIRpcNoticeSceneInfoNotify::set_has_sceneinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIRpcNoticeSceneInfoNotify::clear_has_sceneinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIRpcNoticeSceneInfoNotify::clear_sceneinfo() {
  if (sceneinfo_ != &::google::protobuf::internal::kEmptyString) {
    sceneinfo_->clear();
  }
  clear_has_sceneinfo();
}
inline const ::std::string& AIRpcNoticeSceneInfoNotify::sceneinfo() const {
  return *sceneinfo_;
}
inline void AIRpcNoticeSceneInfoNotify::set_sceneinfo(const ::std::string& value) {
  set_has_sceneinfo();
  if (sceneinfo_ == &::google::protobuf::internal::kEmptyString) {
    sceneinfo_ = new ::std::string;
  }
  sceneinfo_->assign(value);
}
inline void AIRpcNoticeSceneInfoNotify::set_sceneinfo(const char* value) {
  set_has_sceneinfo();
  if (sceneinfo_ == &::google::protobuf::internal::kEmptyString) {
    sceneinfo_ = new ::std::string;
  }
  sceneinfo_->assign(value);
}
inline void AIRpcNoticeSceneInfoNotify::set_sceneinfo(const void* value, size_t size) {
  set_has_sceneinfo();
  if (sceneinfo_ == &::google::protobuf::internal::kEmptyString) {
    sceneinfo_ = new ::std::string;
  }
  sceneinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIRpcNoticeSceneInfoNotify::mutable_sceneinfo() {
  set_has_sceneinfo();
  if (sceneinfo_ == &::google::protobuf::internal::kEmptyString) {
    sceneinfo_ = new ::std::string;
  }
  return sceneinfo_;
}
inline ::std::string* AIRpcNoticeSceneInfoNotify::release_sceneinfo() {
  clear_has_sceneinfo();
  if (sceneinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sceneinfo_;
    sceneinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AIRpcNoticeSceneInfoNotify::set_allocated_sceneinfo(::std::string* sceneinfo) {
  if (sceneinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete sceneinfo_;
  }
  if (sceneinfo) {
    set_has_sceneinfo();
    sceneinfo_ = sceneinfo;
  } else {
    clear_has_sceneinfo();
    sceneinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AIRpcNoticeUpdateSceneInfoNotify

// optional sint64 SceneId = 1 [default = -1];
inline bool AIRpcNoticeUpdateSceneInfoNotify::has_sceneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_has_sceneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(-1);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 AIRpcNoticeUpdateSceneInfoNotify::sceneid() const {
  return sceneid_;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}

// repeated .AIUserData Userinfo = 3;
inline int AIRpcNoticeUpdateSceneInfoNotify::userinfo_size() const {
  return userinfo_.size();
}
inline void AIRpcNoticeUpdateSceneInfoNotify::clear_userinfo() {
  userinfo_.Clear();
}
inline const ::AIUserData& AIRpcNoticeUpdateSceneInfoNotify::userinfo(int index) const {
  return userinfo_.Get(index);
}
inline ::AIUserData* AIRpcNoticeUpdateSceneInfoNotify::mutable_userinfo(int index) {
  return userinfo_.Mutable(index);
}
inline ::AIUserData* AIRpcNoticeUpdateSceneInfoNotify::add_userinfo() {
  return userinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AIUserData >&
AIRpcNoticeUpdateSceneInfoNotify::userinfo() const {
  return userinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::AIUserData >*
AIRpcNoticeUpdateSceneInfoNotify::mutable_userinfo() {
  return &userinfo_;
}

// repeated bytes Sprayinfo = 4;
inline int AIRpcNoticeUpdateSceneInfoNotify::sprayinfo_size() const {
  return sprayinfo_.size();
}
inline void AIRpcNoticeUpdateSceneInfoNotify::clear_sprayinfo() {
  sprayinfo_.Clear();
}
inline const ::std::string& AIRpcNoticeUpdateSceneInfoNotify::sprayinfo(int index) const {
  return sprayinfo_.Get(index);
}
inline ::std::string* AIRpcNoticeUpdateSceneInfoNotify::mutable_sprayinfo(int index) {
  return sprayinfo_.Mutable(index);
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_sprayinfo(int index, const ::std::string& value) {
  sprayinfo_.Mutable(index)->assign(value);
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_sprayinfo(int index, const char* value) {
  sprayinfo_.Mutable(index)->assign(value);
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_sprayinfo(int index, const void* value, size_t size) {
  sprayinfo_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIRpcNoticeUpdateSceneInfoNotify::add_sprayinfo() {
  return sprayinfo_.Add();
}
inline void AIRpcNoticeUpdateSceneInfoNotify::add_sprayinfo(const ::std::string& value) {
  sprayinfo_.Add()->assign(value);
}
inline void AIRpcNoticeUpdateSceneInfoNotify::add_sprayinfo(const char* value) {
  sprayinfo_.Add()->assign(value);
}
inline void AIRpcNoticeUpdateSceneInfoNotify::add_sprayinfo(const void* value, size_t size) {
  sprayinfo_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIRpcNoticeUpdateSceneInfoNotify::sprayinfo() const {
  return sprayinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIRpcNoticeUpdateSceneInfoNotify::mutable_sprayinfo() {
  return &sprayinfo_;
}

// optional sint64 Sendtime = 5 [default = -1];
inline bool AIRpcNoticeUpdateSceneInfoNotify::has_sendtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_has_sendtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::clear_sendtime() {
  sendtime_ = GOOGLE_LONGLONG(-1);
  clear_has_sendtime();
}
inline ::google::protobuf::int64 AIRpcNoticeUpdateSceneInfoNotify::sendtime() const {
  return sendtime_;
}
inline void AIRpcNoticeUpdateSceneInfoNotify::set_sendtime(::google::protobuf::int64 value) {
  set_has_sendtime();
  sendtime_ = value;
}

// -------------------------------------------------------------------

// AIUserData

// optional .AIUserCom Usercom = 3;
inline bool AIUserData::has_usercom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIUserData::set_has_usercom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIUserData::clear_has_usercom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIUserData::clear_usercom() {
  if (usercom_ != NULL) usercom_->::AIUserCom::Clear();
  clear_has_usercom();
}
inline const ::AIUserCom& AIUserData::usercom() const {
  return usercom_ != NULL ? *usercom_ : *default_instance_->usercom_;
}
inline ::AIUserCom* AIUserData::mutable_usercom() {
  set_has_usercom();
  if (usercom_ == NULL) usercom_ = new ::AIUserCom;
  return usercom_;
}
inline ::AIUserCom* AIUserData::release_usercom() {
  clear_has_usercom();
  ::AIUserCom* temp = usercom_;
  usercom_ = NULL;
  return temp;
}
inline void AIUserData::set_allocated_usercom(::AIUserCom* usercom) {
  delete usercom_;
  usercom_ = usercom;
  if (usercom) {
    set_has_usercom();
  } else {
    clear_has_usercom();
  }
}

// optional .AIUserPosCom Userposinfo = 4;
inline bool AIUserData::has_userposinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIUserData::set_has_userposinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIUserData::clear_has_userposinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIUserData::clear_userposinfo() {
  if (userposinfo_ != NULL) userposinfo_->::AIUserPosCom::Clear();
  clear_has_userposinfo();
}
inline const ::AIUserPosCom& AIUserData::userposinfo() const {
  return userposinfo_ != NULL ? *userposinfo_ : *default_instance_->userposinfo_;
}
inline ::AIUserPosCom* AIUserData::mutable_userposinfo() {
  set_has_userposinfo();
  if (userposinfo_ == NULL) userposinfo_ = new ::AIUserPosCom;
  return userposinfo_;
}
inline ::AIUserPosCom* AIUserData::release_userposinfo() {
  clear_has_userposinfo();
  ::AIUserPosCom* temp = userposinfo_;
  userposinfo_ = NULL;
  return temp;
}
inline void AIUserData::set_allocated_userposinfo(::AIUserPosCom* userposinfo) {
  delete userposinfo_;
  userposinfo_ = userposinfo;
  if (userposinfo) {
    set_has_userposinfo();
  } else {
    clear_has_userposinfo();
  }
}

// optional .AIUserProp Userprop = 5;
inline bool AIUserData::has_userprop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIUserData::set_has_userprop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIUserData::clear_has_userprop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIUserData::clear_userprop() {
  if (userprop_ != NULL) userprop_->::AIUserProp::Clear();
  clear_has_userprop();
}
inline const ::AIUserProp& AIUserData::userprop() const {
  return userprop_ != NULL ? *userprop_ : *default_instance_->userprop_;
}
inline ::AIUserProp* AIUserData::mutable_userprop() {
  set_has_userprop();
  if (userprop_ == NULL) userprop_ = new ::AIUserProp;
  return userprop_;
}
inline ::AIUserProp* AIUserData::release_userprop() {
  clear_has_userprop();
  ::AIUserProp* temp = userprop_;
  userprop_ = NULL;
  return temp;
}
inline void AIUserData::set_allocated_userprop(::AIUserProp* userprop) {
  delete userprop_;
  userprop_ = userprop;
  if (userprop) {
    set_has_userprop();
  } else {
    clear_has_userprop();
  }
}

// repeated bytes UseskillRet = 6;
inline int AIUserData::useskillret_size() const {
  return useskillret_.size();
}
inline void AIUserData::clear_useskillret() {
  useskillret_.Clear();
}
inline const ::std::string& AIUserData::useskillret(int index) const {
  return useskillret_.Get(index);
}
inline ::std::string* AIUserData::mutable_useskillret(int index) {
  return useskillret_.Mutable(index);
}
inline void AIUserData::set_useskillret(int index, const ::std::string& value) {
  useskillret_.Mutable(index)->assign(value);
}
inline void AIUserData::set_useskillret(int index, const char* value) {
  useskillret_.Mutable(index)->assign(value);
}
inline void AIUserData::set_useskillret(int index, const void* value, size_t size) {
  useskillret_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIUserData::add_useskillret() {
  return useskillret_.Add();
}
inline void AIUserData::add_useskillret(const ::std::string& value) {
  useskillret_.Add()->assign(value);
}
inline void AIUserData::add_useskillret(const char* value) {
  useskillret_.Add()->assign(value);
}
inline void AIUserData::add_useskillret(const void* value, size_t size) {
  useskillret_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIUserData::useskillret() const {
  return useskillret_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIUserData::mutable_useskillret() {
  return &useskillret_;
}

// repeated bytes ShootRet = 7;
inline int AIUserData::shootret_size() const {
  return shootret_.size();
}
inline void AIUserData::clear_shootret() {
  shootret_.Clear();
}
inline const ::std::string& AIUserData::shootret(int index) const {
  return shootret_.Get(index);
}
inline ::std::string* AIUserData::mutable_shootret(int index) {
  return shootret_.Mutable(index);
}
inline void AIUserData::set_shootret(int index, const ::std::string& value) {
  shootret_.Mutable(index)->assign(value);
}
inline void AIUserData::set_shootret(int index, const char* value) {
  shootret_.Mutable(index)->assign(value);
}
inline void AIUserData::set_shootret(int index, const void* value, size_t size) {
  shootret_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AIUserData::add_shootret() {
  return shootret_.Add();
}
inline void AIUserData::add_shootret(const ::std::string& value) {
  shootret_.Add()->assign(value);
}
inline void AIUserData::add_shootret(const char* value) {
  shootret_.Add()->assign(value);
}
inline void AIUserData::add_shootret(const void* value, size_t size) {
  shootret_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AIUserData::shootret() const {
  return shootret_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AIUserData::mutable_shootret() {
  return &shootret_;
}

// -------------------------------------------------------------------

// AIUserCom

// optional sint64 Uid = 1 [default = -1];
inline bool AIUserCom::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIUserCom::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIUserCom::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIUserCom::clear_uid() {
  uid_ = GOOGLE_LONGLONG(-1);
  clear_has_uid();
}
inline ::google::protobuf::int64 AIUserCom::uid() const {
  return uid_;
}
inline void AIUserCom::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional bool Dead = 2 [default = false];
inline bool AIUserCom::has_dead() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIUserCom::set_has_dead() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIUserCom::clear_has_dead() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIUserCom::clear_dead() {
  dead_ = false;
  clear_has_dead();
}
inline bool AIUserCom::dead() const {
  return dead_;
}
inline void AIUserCom::set_dead(bool value) {
  set_has_dead();
  dead_ = value;
}

// optional .Vector3PB Revivepos = 3;
inline bool AIUserCom::has_revivepos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIUserCom::set_has_revivepos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIUserCom::clear_has_revivepos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIUserCom::clear_revivepos() {
  if (revivepos_ != NULL) revivepos_->::Vector3PB::Clear();
  clear_has_revivepos();
}
inline const ::Vector3PB& AIUserCom::revivepos() const {
  return revivepos_ != NULL ? *revivepos_ : *default_instance_->revivepos_;
}
inline ::Vector3PB* AIUserCom::mutable_revivepos() {
  set_has_revivepos();
  if (revivepos_ == NULL) revivepos_ = new ::Vector3PB;
  return revivepos_;
}
inline ::Vector3PB* AIUserCom::release_revivepos() {
  clear_has_revivepos();
  ::Vector3PB* temp = revivepos_;
  revivepos_ = NULL;
  return temp;
}
inline void AIUserCom::set_allocated_revivepos(::Vector3PB* revivepos) {
  delete revivepos_;
  revivepos_ = revivepos;
  if (revivepos) {
    set_has_revivepos();
  } else {
    clear_has_revivepos();
  }
}

// optional .Vector3PB FaceDir = 4;
inline bool AIUserCom::has_facedir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIUserCom::set_has_facedir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIUserCom::clear_has_facedir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIUserCom::clear_facedir() {
  if (facedir_ != NULL) facedir_->::Vector3PB::Clear();
  clear_has_facedir();
}
inline const ::Vector3PB& AIUserCom::facedir() const {
  return facedir_ != NULL ? *facedir_ : *default_instance_->facedir_;
}
inline ::Vector3PB* AIUserCom::mutable_facedir() {
  set_has_facedir();
  if (facedir_ == NULL) facedir_ = new ::Vector3PB;
  return facedir_;
}
inline ::Vector3PB* AIUserCom::release_facedir() {
  clear_has_facedir();
  ::Vector3PB* temp = facedir_;
  facedir_ = NULL;
  return temp;
}
inline void AIUserCom::set_allocated_facedir(::Vector3PB* facedir) {
  delete facedir_;
  facedir_ = facedir;
  if (facedir) {
    set_has_facedir();
  } else {
    clear_has_facedir();
  }
}

// -------------------------------------------------------------------

// AIUserProp

// optional float Hp = 1 [default = -1];
inline bool AIUserProp::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIUserProp::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIUserProp::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIUserProp::clear_hp() {
  hp_ = -1;
  clear_has_hp();
}
inline float AIUserProp::hp() const {
  return hp_;
}
inline void AIUserProp::set_hp(float value) {
  set_has_hp();
  hp_ = value;
}

// optional float Energy = 2 [default = -1];
inline bool AIUserProp::has_energy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIUserProp::set_has_energy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIUserProp::clear_has_energy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIUserProp::clear_energy() {
  energy_ = -1;
  clear_has_energy();
}
inline float AIUserProp::energy() const {
  return energy_;
}
inline void AIUserProp::set_energy(float value) {
  set_has_energy();
  energy_ = value;
}

// -------------------------------------------------------------------

// AIUserPosCom

// optional bool Bmoving = 1 [default = false];
inline bool AIUserPosCom::has_bmoving() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIUserPosCom::set_has_bmoving() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIUserPosCom::clear_has_bmoving() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIUserPosCom::clear_bmoving() {
  bmoving_ = false;
  clear_has_bmoving();
}
inline bool AIUserPosCom::bmoving() const {
  return bmoving_;
}
inline void AIUserPosCom::set_bmoving(bool value) {
  set_has_bmoving();
  bmoving_ = value;
}

// optional .Vector3PB Footray = 2;
inline bool AIUserPosCom::has_footray() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIUserPosCom::set_has_footray() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIUserPosCom::clear_has_footray() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIUserPosCom::clear_footray() {
  if (footray_ != NULL) footray_->::Vector3PB::Clear();
  clear_has_footray();
}
inline const ::Vector3PB& AIUserPosCom::footray() const {
  return footray_ != NULL ? *footray_ : *default_instance_->footray_;
}
inline ::Vector3PB* AIUserPosCom::mutable_footray() {
  set_has_footray();
  if (footray_ == NULL) footray_ = new ::Vector3PB;
  return footray_;
}
inline ::Vector3PB* AIUserPosCom::release_footray() {
  clear_has_footray();
  ::Vector3PB* temp = footray_;
  footray_ = NULL;
  return temp;
}
inline void AIUserPosCom::set_allocated_footray(::Vector3PB* footray) {
  delete footray_;
  footray_ = footray;
  if (footray) {
    set_has_footray();
  } else {
    clear_has_footray();
  }
}

// optional .Vector3PB Rockdir = 3;
inline bool AIUserPosCom::has_rockdir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AIUserPosCom::set_has_rockdir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AIUserPosCom::clear_has_rockdir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AIUserPosCom::clear_rockdir() {
  if (rockdir_ != NULL) rockdir_->::Vector3PB::Clear();
  clear_has_rockdir();
}
inline const ::Vector3PB& AIUserPosCom::rockdir() const {
  return rockdir_ != NULL ? *rockdir_ : *default_instance_->rockdir_;
}
inline ::Vector3PB* AIUserPosCom::mutable_rockdir() {
  set_has_rockdir();
  if (rockdir_ == NULL) rockdir_ = new ::Vector3PB;
  return rockdir_;
}
inline ::Vector3PB* AIUserPosCom::release_rockdir() {
  clear_has_rockdir();
  ::Vector3PB* temp = rockdir_;
  rockdir_ = NULL;
  return temp;
}
inline void AIUserPosCom::set_allocated_rockdir(::Vector3PB* rockdir) {
  delete rockdir_;
  rockdir_ = rockdir;
  if (rockdir) {
    set_has_rockdir();
  } else {
    clear_has_rockdir();
  }
}

// optional .Vector3PB Movedir = 4;
inline bool AIUserPosCom::has_movedir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AIUserPosCom::set_has_movedir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AIUserPosCom::clear_has_movedir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AIUserPosCom::clear_movedir() {
  if (movedir_ != NULL) movedir_->::Vector3PB::Clear();
  clear_has_movedir();
}
inline const ::Vector3PB& AIUserPosCom::movedir() const {
  return movedir_ != NULL ? *movedir_ : *default_instance_->movedir_;
}
inline ::Vector3PB* AIUserPosCom::mutable_movedir() {
  set_has_movedir();
  if (movedir_ == NULL) movedir_ = new ::Vector3PB;
  return movedir_;
}
inline ::Vector3PB* AIUserPosCom::release_movedir() {
  clear_has_movedir();
  ::Vector3PB* temp = movedir_;
  movedir_ = NULL;
  return temp;
}
inline void AIUserPosCom::set_allocated_movedir(::Vector3PB* movedir) {
  delete movedir_;
  movedir_ = movedir;
  if (movedir) {
    set_has_movedir();
  } else {
    clear_has_movedir();
  }
}

// optional .Vector3PB Pos = 5;
inline bool AIUserPosCom::has_pos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AIUserPosCom::set_has_pos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AIUserPosCom::clear_has_pos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AIUserPosCom::clear_pos() {
  if (pos_ != NULL) pos_->::Vector3PB::Clear();
  clear_has_pos();
}
inline const ::Vector3PB& AIUserPosCom::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Vector3PB* AIUserPosCom::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Vector3PB;
  return pos_;
}
inline ::Vector3PB* AIUserPosCom::release_pos() {
  clear_has_pos();
  ::Vector3PB* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void AIUserPosCom::set_allocated_pos(::Vector3PB* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// -------------------------------------------------------------------

// AIRpcDeleteUserNotify

// optional sint64 Uid = 1 [default = -1];
inline bool AIRpcDeleteUserNotify::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AIRpcDeleteUserNotify::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AIRpcDeleteUserNotify::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AIRpcDeleteUserNotify::clear_uid() {
  uid_ = GOOGLE_LONGLONG(-1);
  clear_has_uid();
}
inline ::google::protobuf::int64 AIRpcDeleteUserNotify::uid() const {
  return uid_;
}
inline void AIRpcDeleteUserNotify::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
}

// optional sint64 SceneId = 2 [default = -1];
inline bool AIRpcDeleteUserNotify::has_sceneid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AIRpcDeleteUserNotify::set_has_sceneid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AIRpcDeleteUserNotify::clear_has_sceneid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AIRpcDeleteUserNotify::clear_sceneid() {
  sceneid_ = GOOGLE_LONGLONG(-1);
  clear_has_sceneid();
}
inline ::google::protobuf::int64 AIRpcDeleteUserNotify::sceneid() const {
  return sceneid_;
}
inline void AIRpcDeleteUserNotify::set_sceneid(::google::protobuf::int64 value) {
  set_has_sceneid();
  sceneid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AISvrRpc_2eproto__INCLUDED
