// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DBCacheSvrRpc.proto

#ifndef PROTOBUF_DBCacheSvrRpc_2eproto__INCLUDED
#define PROTOBUF_DBCacheSvrRpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PublicStruct.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

class DBCacheRpcInsertAsk;
class DBCacheRpcInsertReply;
class DBCacheRpcDeleteAsk;
class DBCacheRpcDeleteReply;
class DBCacheRpcUpdateAsk;
class DBCacheRpcUpdateReply;
class DBCacheRpcSelectAsk;
class DBCacheRpcSelectReply;
class DBCacheFV;
class DBCacheRecordLine;

// ===================================================================

class DBCacheRpcInsertAsk : public ::google::protobuf::Message {
 public:
  DBCacheRpcInsertAsk();
  virtual ~DBCacheRpcInsertAsk();

  DBCacheRpcInsertAsk(const DBCacheRpcInsertAsk& from);

  inline DBCacheRpcInsertAsk& operator=(const DBCacheRpcInsertAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcInsertAsk& default_instance();

  void Swap(DBCacheRpcInsertAsk* other);

  // implements Message ----------------------------------------------

  DBCacheRpcInsertAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcInsertAsk& from);
  void MergeFrom(const DBCacheRpcInsertAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TabName = 1;
  inline bool has_tabname() const;
  inline void clear_tabname();
  static const int kTabNameFieldNumber = 1;
  inline const ::std::string& tabname() const;
  inline void set_tabname(const ::std::string& value);
  inline void set_tabname(const char* value);
  inline void set_tabname(const char* value, size_t size);
  inline ::std::string* mutable_tabname();
  inline ::std::string* release_tabname();
  inline void set_allocated_tabname(::std::string* tabname);

  // optional string PrimaryKey = 2;
  inline bool has_primarykey() const;
  inline void clear_primarykey();
  static const int kPrimaryKeyFieldNumber = 2;
  inline const ::std::string& primarykey() const;
  inline void set_primarykey(const ::std::string& value);
  inline void set_primarykey(const char* value);
  inline void set_primarykey(const char* value, size_t size);
  inline ::std::string* mutable_primarykey();
  inline ::std::string* release_primarykey();
  inline void set_allocated_primarykey(::std::string* primarykey);

  // optional string SubsidiaryKey = 3;
  inline bool has_subsidiarykey() const;
  inline void clear_subsidiarykey();
  static const int kSubsidiaryKeyFieldNumber = 3;
  inline const ::std::string& subsidiarykey() const;
  inline void set_subsidiarykey(const ::std::string& value);
  inline void set_subsidiarykey(const char* value);
  inline void set_subsidiarykey(const char* value, size_t size);
  inline ::std::string* mutable_subsidiarykey();
  inline ::std::string* release_subsidiarykey();
  inline void set_allocated_subsidiarykey(::std::string* subsidiarykey);

  // optional string PKValue = 4;
  inline bool has_pkvalue() const;
  inline void clear_pkvalue();
  static const int kPKValueFieldNumber = 4;
  inline const ::std::string& pkvalue() const;
  inline void set_pkvalue(const ::std::string& value);
  inline void set_pkvalue(const char* value);
  inline void set_pkvalue(const char* value, size_t size);
  inline ::std::string* mutable_pkvalue();
  inline ::std::string* release_pkvalue();
  inline void set_allocated_pkvalue(::std::string* pkvalue);

  // optional string SKValue = 6;
  inline bool has_skvalue() const;
  inline void clear_skvalue();
  static const int kSKValueFieldNumber = 6;
  inline const ::std::string& skvalue() const;
  inline void set_skvalue(const ::std::string& value);
  inline void set_skvalue(const char* value);
  inline void set_skvalue(const char* value, size_t size);
  inline ::std::string* mutable_skvalue();
  inline ::std::string* release_skvalue();
  inline void set_allocated_skvalue(::std::string* skvalue);

  // repeated .DBCacheFV FVArray = 5;
  inline int fvarray_size() const;
  inline void clear_fvarray();
  static const int kFVArrayFieldNumber = 5;
  inline const ::DBCacheFV& fvarray(int index) const;
  inline ::DBCacheFV* mutable_fvarray(int index);
  inline ::DBCacheFV* add_fvarray();
  inline const ::google::protobuf::RepeatedPtrField< ::DBCacheFV >&
      fvarray() const;
  inline ::google::protobuf::RepeatedPtrField< ::DBCacheFV >*
      mutable_fvarray();

  // @@protoc_insertion_point(class_scope:DBCacheRpcInsertAsk)
 private:
  inline void set_has_tabname();
  inline void clear_has_tabname();
  inline void set_has_primarykey();
  inline void clear_has_primarykey();
  inline void set_has_subsidiarykey();
  inline void clear_has_subsidiarykey();
  inline void set_has_pkvalue();
  inline void clear_has_pkvalue();
  inline void set_has_skvalue();
  inline void clear_has_skvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tabname_;
  ::std::string* primarykey_;
  ::std::string* subsidiarykey_;
  ::std::string* pkvalue_;
  ::std::string* skvalue_;
  ::google::protobuf::RepeatedPtrField< ::DBCacheFV > fvarray_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcInsertAsk* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcInsertReply : public ::google::protobuf::Message {
 public:
  DBCacheRpcInsertReply();
  virtual ~DBCacheRpcInsertReply();

  DBCacheRpcInsertReply(const DBCacheRpcInsertReply& from);

  inline DBCacheRpcInsertReply& operator=(const DBCacheRpcInsertReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcInsertReply& default_instance();

  void Swap(DBCacheRpcInsertReply* other);

  // implements Message ----------------------------------------------

  DBCacheRpcInsertReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcInsertReply& from);
  void MergeFrom(const DBCacheRpcInsertReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DBCacheRpcInsertReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcInsertReply* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcDeleteAsk : public ::google::protobuf::Message {
 public:
  DBCacheRpcDeleteAsk();
  virtual ~DBCacheRpcDeleteAsk();

  DBCacheRpcDeleteAsk(const DBCacheRpcDeleteAsk& from);

  inline DBCacheRpcDeleteAsk& operator=(const DBCacheRpcDeleteAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcDeleteAsk& default_instance();

  void Swap(DBCacheRpcDeleteAsk* other);

  // implements Message ----------------------------------------------

  DBCacheRpcDeleteAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcDeleteAsk& from);
  void MergeFrom(const DBCacheRpcDeleteAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TabName = 1;
  inline bool has_tabname() const;
  inline void clear_tabname();
  static const int kTabNameFieldNumber = 1;
  inline const ::std::string& tabname() const;
  inline void set_tabname(const ::std::string& value);
  inline void set_tabname(const char* value);
  inline void set_tabname(const char* value, size_t size);
  inline ::std::string* mutable_tabname();
  inline ::std::string* release_tabname();
  inline void set_allocated_tabname(::std::string* tabname);

  // optional string PrimaryKey = 2;
  inline bool has_primarykey() const;
  inline void clear_primarykey();
  static const int kPrimaryKeyFieldNumber = 2;
  inline const ::std::string& primarykey() const;
  inline void set_primarykey(const ::std::string& value);
  inline void set_primarykey(const char* value);
  inline void set_primarykey(const char* value, size_t size);
  inline ::std::string* mutable_primarykey();
  inline ::std::string* release_primarykey();
  inline void set_allocated_primarykey(::std::string* primarykey);

  // optional string SubsidiaryKey = 3;
  inline bool has_subsidiarykey() const;
  inline void clear_subsidiarykey();
  static const int kSubsidiaryKeyFieldNumber = 3;
  inline const ::std::string& subsidiarykey() const;
  inline void set_subsidiarykey(const ::std::string& value);
  inline void set_subsidiarykey(const char* value);
  inline void set_subsidiarykey(const char* value, size_t size);
  inline ::std::string* mutable_subsidiarykey();
  inline ::std::string* release_subsidiarykey();
  inline void set_allocated_subsidiarykey(::std::string* subsidiarykey);

  // optional sint32 Type = 4 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string KeyValue = 5;
  inline bool has_keyvalue() const;
  inline void clear_keyvalue();
  static const int kKeyValueFieldNumber = 5;
  inline const ::std::string& keyvalue() const;
  inline void set_keyvalue(const ::std::string& value);
  inline void set_keyvalue(const char* value);
  inline void set_keyvalue(const char* value, size_t size);
  inline ::std::string* mutable_keyvalue();
  inline ::std::string* release_keyvalue();
  inline void set_allocated_keyvalue(::std::string* keyvalue);

  // @@protoc_insertion_point(class_scope:DBCacheRpcDeleteAsk)
 private:
  inline void set_has_tabname();
  inline void clear_has_tabname();
  inline void set_has_primarykey();
  inline void clear_has_primarykey();
  inline void set_has_subsidiarykey();
  inline void clear_has_subsidiarykey();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_keyvalue();
  inline void clear_has_keyvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tabname_;
  ::std::string* primarykey_;
  ::std::string* subsidiarykey_;
  ::std::string* keyvalue_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcDeleteAsk* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcDeleteReply : public ::google::protobuf::Message {
 public:
  DBCacheRpcDeleteReply();
  virtual ~DBCacheRpcDeleteReply();

  DBCacheRpcDeleteReply(const DBCacheRpcDeleteReply& from);

  inline DBCacheRpcDeleteReply& operator=(const DBCacheRpcDeleteReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcDeleteReply& default_instance();

  void Swap(DBCacheRpcDeleteReply* other);

  // implements Message ----------------------------------------------

  DBCacheRpcDeleteReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcDeleteReply& from);
  void MergeFrom(const DBCacheRpcDeleteReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional sint32 NrAffects = 2 [default = 0];
  inline bool has_nraffects() const;
  inline void clear_nraffects();
  static const int kNrAffectsFieldNumber = 2;
  inline ::google::protobuf::int32 nraffects() const;
  inline void set_nraffects(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DBCacheRpcDeleteReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_nraffects();
  inline void clear_has_nraffects();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 nraffects_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcDeleteReply* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcUpdateAsk : public ::google::protobuf::Message {
 public:
  DBCacheRpcUpdateAsk();
  virtual ~DBCacheRpcUpdateAsk();

  DBCacheRpcUpdateAsk(const DBCacheRpcUpdateAsk& from);

  inline DBCacheRpcUpdateAsk& operator=(const DBCacheRpcUpdateAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcUpdateAsk& default_instance();

  void Swap(DBCacheRpcUpdateAsk* other);

  // implements Message ----------------------------------------------

  DBCacheRpcUpdateAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcUpdateAsk& from);
  void MergeFrom(const DBCacheRpcUpdateAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TabName = 1;
  inline bool has_tabname() const;
  inline void clear_tabname();
  static const int kTabNameFieldNumber = 1;
  inline const ::std::string& tabname() const;
  inline void set_tabname(const ::std::string& value);
  inline void set_tabname(const char* value);
  inline void set_tabname(const char* value, size_t size);
  inline ::std::string* mutable_tabname();
  inline ::std::string* release_tabname();
  inline void set_allocated_tabname(::std::string* tabname);

  // optional string PrimaryKey = 2;
  inline bool has_primarykey() const;
  inline void clear_primarykey();
  static const int kPrimaryKeyFieldNumber = 2;
  inline const ::std::string& primarykey() const;
  inline void set_primarykey(const ::std::string& value);
  inline void set_primarykey(const char* value);
  inline void set_primarykey(const char* value, size_t size);
  inline ::std::string* mutable_primarykey();
  inline ::std::string* release_primarykey();
  inline void set_allocated_primarykey(::std::string* primarykey);

  // optional string SubsidiaryKey = 6;
  inline bool has_subsidiarykey() const;
  inline void clear_subsidiarykey();
  static const int kSubsidiaryKeyFieldNumber = 6;
  inline const ::std::string& subsidiarykey() const;
  inline void set_subsidiarykey(const ::std::string& value);
  inline void set_subsidiarykey(const char* value);
  inline void set_subsidiarykey(const char* value, size_t size);
  inline ::std::string* mutable_subsidiarykey();
  inline ::std::string* release_subsidiarykey();
  inline void set_allocated_subsidiarykey(::std::string* subsidiarykey);

  // optional string PKValue = 4;
  inline bool has_pkvalue() const;
  inline void clear_pkvalue();
  static const int kPKValueFieldNumber = 4;
  inline const ::std::string& pkvalue() const;
  inline void set_pkvalue(const ::std::string& value);
  inline void set_pkvalue(const char* value);
  inline void set_pkvalue(const char* value, size_t size);
  inline ::std::string* mutable_pkvalue();
  inline ::std::string* release_pkvalue();
  inline void set_allocated_pkvalue(::std::string* pkvalue);

  // repeated .DBCacheFV FVArray = 5;
  inline int fvarray_size() const;
  inline void clear_fvarray();
  static const int kFVArrayFieldNumber = 5;
  inline const ::DBCacheFV& fvarray(int index) const;
  inline ::DBCacheFV* mutable_fvarray(int index);
  inline ::DBCacheFV* add_fvarray();
  inline const ::google::protobuf::RepeatedPtrField< ::DBCacheFV >&
      fvarray() const;
  inline ::google::protobuf::RepeatedPtrField< ::DBCacheFV >*
      mutable_fvarray();

  // @@protoc_insertion_point(class_scope:DBCacheRpcUpdateAsk)
 private:
  inline void set_has_tabname();
  inline void clear_has_tabname();
  inline void set_has_primarykey();
  inline void clear_has_primarykey();
  inline void set_has_subsidiarykey();
  inline void clear_has_subsidiarykey();
  inline void set_has_pkvalue();
  inline void clear_has_pkvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tabname_;
  ::std::string* primarykey_;
  ::std::string* subsidiarykey_;
  ::std::string* pkvalue_;
  ::google::protobuf::RepeatedPtrField< ::DBCacheFV > fvarray_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcUpdateAsk* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcUpdateReply : public ::google::protobuf::Message {
 public:
  DBCacheRpcUpdateReply();
  virtual ~DBCacheRpcUpdateReply();

  DBCacheRpcUpdateReply(const DBCacheRpcUpdateReply& from);

  inline DBCacheRpcUpdateReply& operator=(const DBCacheRpcUpdateReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcUpdateReply& default_instance();

  void Swap(DBCacheRpcUpdateReply* other);

  // implements Message ----------------------------------------------

  DBCacheRpcUpdateReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcUpdateReply& from);
  void MergeFrom(const DBCacheRpcUpdateReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DBCacheRpcUpdateReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcUpdateReply* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcSelectAsk : public ::google::protobuf::Message {
 public:
  DBCacheRpcSelectAsk();
  virtual ~DBCacheRpcSelectAsk();

  DBCacheRpcSelectAsk(const DBCacheRpcSelectAsk& from);

  inline DBCacheRpcSelectAsk& operator=(const DBCacheRpcSelectAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcSelectAsk& default_instance();

  void Swap(DBCacheRpcSelectAsk* other);

  // implements Message ----------------------------------------------

  DBCacheRpcSelectAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcSelectAsk& from);
  void MergeFrom(const DBCacheRpcSelectAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string TabName = 1;
  inline bool has_tabname() const;
  inline void clear_tabname();
  static const int kTabNameFieldNumber = 1;
  inline const ::std::string& tabname() const;
  inline void set_tabname(const ::std::string& value);
  inline void set_tabname(const char* value);
  inline void set_tabname(const char* value, size_t size);
  inline ::std::string* mutable_tabname();
  inline ::std::string* release_tabname();
  inline void set_allocated_tabname(::std::string* tabname);

  // optional string PrimaryKey = 2;
  inline bool has_primarykey() const;
  inline void clear_primarykey();
  static const int kPrimaryKeyFieldNumber = 2;
  inline const ::std::string& primarykey() const;
  inline void set_primarykey(const ::std::string& value);
  inline void set_primarykey(const char* value);
  inline void set_primarykey(const char* value, size_t size);
  inline ::std::string* mutable_primarykey();
  inline ::std::string* release_primarykey();
  inline void set_allocated_primarykey(::std::string* primarykey);

  // optional string SubsidiaryKey = 3;
  inline bool has_subsidiarykey() const;
  inline void clear_subsidiarykey();
  static const int kSubsidiaryKeyFieldNumber = 3;
  inline const ::std::string& subsidiarykey() const;
  inline void set_subsidiarykey(const ::std::string& value);
  inline void set_subsidiarykey(const char* value);
  inline void set_subsidiarykey(const char* value, size_t size);
  inline ::std::string* mutable_subsidiarykey();
  inline ::std::string* release_subsidiarykey();
  inline void set_allocated_subsidiarykey(::std::string* subsidiarykey);

  // optional sint32 Type = 4 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string KeyValue = 5;
  inline bool has_keyvalue() const;
  inline void clear_keyvalue();
  static const int kKeyValueFieldNumber = 5;
  inline const ::std::string& keyvalue() const;
  inline void set_keyvalue(const ::std::string& value);
  inline void set_keyvalue(const char* value);
  inline void set_keyvalue(const char* value, size_t size);
  inline ::std::string* mutable_keyvalue();
  inline ::std::string* release_keyvalue();
  inline void set_allocated_keyvalue(::std::string* keyvalue);

  // repeated string Fields = 6;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 6;
  inline const ::std::string& fields(int index) const;
  inline ::std::string* mutable_fields(int index);
  inline void set_fields(int index, const ::std::string& value);
  inline void set_fields(int index, const char* value);
  inline void set_fields(int index, const char* value, size_t size);
  inline ::std::string* add_fields();
  inline void add_fields(const ::std::string& value);
  inline void add_fields(const char* value);
  inline void add_fields(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // @@protoc_insertion_point(class_scope:DBCacheRpcSelectAsk)
 private:
  inline void set_has_tabname();
  inline void clear_has_tabname();
  inline void set_has_primarykey();
  inline void clear_has_primarykey();
  inline void set_has_subsidiarykey();
  inline void clear_has_subsidiarykey();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_keyvalue();
  inline void clear_has_keyvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tabname_;
  ::std::string* primarykey_;
  ::std::string* subsidiarykey_;
  ::std::string* keyvalue_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcSelectAsk* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRpcSelectReply : public ::google::protobuf::Message {
 public:
  DBCacheRpcSelectReply();
  virtual ~DBCacheRpcSelectReply();

  DBCacheRpcSelectReply(const DBCacheRpcSelectReply& from);

  inline DBCacheRpcSelectReply& operator=(const DBCacheRpcSelectReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRpcSelectReply& default_instance();

  void Swap(DBCacheRpcSelectReply* other);

  // implements Message ----------------------------------------------

  DBCacheRpcSelectReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRpcSelectReply& from);
  void MergeFrom(const DBCacheRpcSelectReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Result = 1 [default = -9999];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional sint32 NrAffects = 2 [default = 0];
  inline bool has_nraffects() const;
  inline void clear_nraffects();
  static const int kNrAffectsFieldNumber = 2;
  inline ::google::protobuf::int32 nraffects() const;
  inline void set_nraffects(::google::protobuf::int32 value);

  // repeated string Fields = 3;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 3;
  inline const ::std::string& fields(int index) const;
  inline ::std::string* mutable_fields(int index);
  inline void set_fields(int index, const ::std::string& value);
  inline void set_fields(int index, const char* value);
  inline void set_fields(int index, const char* value, size_t size);
  inline ::std::string* add_fields();
  inline void add_fields(const ::std::string& value);
  inline void add_fields(const char* value);
  inline void add_fields(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fields();

  // repeated .DBCacheRecordLine Records = 4;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 4;
  inline const ::DBCacheRecordLine& records(int index) const;
  inline ::DBCacheRecordLine* mutable_records(int index);
  inline ::DBCacheRecordLine* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::DBCacheRecordLine >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::DBCacheRecordLine >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:DBCacheRpcSelectReply)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_nraffects();
  inline void clear_has_nraffects();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 nraffects_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fields_;
  ::google::protobuf::RepeatedPtrField< ::DBCacheRecordLine > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRpcSelectReply* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheFV : public ::google::protobuf::Message {
 public:
  DBCacheFV();
  virtual ~DBCacheFV();

  DBCacheFV(const DBCacheFV& from);

  inline DBCacheFV& operator=(const DBCacheFV& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheFV& default_instance();

  void Swap(DBCacheFV* other);

  // implements Message ----------------------------------------------

  DBCacheFV* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheFV& from);
  void MergeFrom(const DBCacheFV& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Field = 1;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::std::string& field() const;
  inline void set_field(const ::std::string& value);
  inline void set_field(const char* value);
  inline void set_field(const char* value, size_t size);
  inline ::std::string* mutable_field();
  inline ::std::string* release_field();
  inline void set_allocated_field(::std::string* field);

  // optional string Value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:DBCacheFV)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* field_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheFV* default_instance_;
};
// -------------------------------------------------------------------

class DBCacheRecordLine : public ::google::protobuf::Message {
 public:
  DBCacheRecordLine();
  virtual ~DBCacheRecordLine();

  DBCacheRecordLine(const DBCacheRecordLine& from);

  inline DBCacheRecordLine& operator=(const DBCacheRecordLine& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBCacheRecordLine& default_instance();

  void Swap(DBCacheRecordLine* other);

  // implements Message ----------------------------------------------

  DBCacheRecordLine* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBCacheRecordLine& from);
  void MergeFrom(const DBCacheRecordLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string Values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::std::string& values(int index) const;
  inline ::std::string* mutable_values(int index);
  inline void set_values(int index, const ::std::string& value);
  inline void set_values(int index, const char* value);
  inline void set_values(int index, const char* value, size_t size);
  inline ::std::string* add_values();
  inline void add_values(const ::std::string& value);
  inline void add_values(const char* value);
  inline void add_values(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:DBCacheRecordLine)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> values_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_AssignDesc_DBCacheSvrRpc_2eproto();
  friend void protobuf_ShutdownFile_DBCacheSvrRpc_2eproto();

  void InitAsDefaultInstance();
  static DBCacheRecordLine* default_instance_;
};
// ===================================================================


// ===================================================================

// DBCacheRpcInsertAsk

// optional string TabName = 1;
inline bool DBCacheRpcInsertAsk::has_tabname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcInsertAsk::set_has_tabname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcInsertAsk::clear_has_tabname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcInsertAsk::clear_tabname() {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    tabname_->clear();
  }
  clear_has_tabname();
}
inline const ::std::string& DBCacheRpcInsertAsk::tabname() const {
  return *tabname_;
}
inline void DBCacheRpcInsertAsk::set_tabname(const ::std::string& value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_tabname(const char* value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_tabname(const char* value, size_t size) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcInsertAsk::mutable_tabname() {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  return tabname_;
}
inline ::std::string* DBCacheRpcInsertAsk::release_tabname() {
  clear_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tabname_;
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcInsertAsk::set_allocated_tabname(::std::string* tabname) {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    delete tabname_;
  }
  if (tabname) {
    set_has_tabname();
    tabname_ = tabname;
  } else {
    clear_has_tabname();
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PrimaryKey = 2;
inline bool DBCacheRpcInsertAsk::has_primarykey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheRpcInsertAsk::set_has_primarykey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheRpcInsertAsk::clear_has_primarykey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheRpcInsertAsk::clear_primarykey() {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    primarykey_->clear();
  }
  clear_has_primarykey();
}
inline const ::std::string& DBCacheRpcInsertAsk::primarykey() const {
  return *primarykey_;
}
inline void DBCacheRpcInsertAsk::set_primarykey(const ::std::string& value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_primarykey(const char* value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_primarykey(const char* value, size_t size) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcInsertAsk::mutable_primarykey() {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  return primarykey_;
}
inline ::std::string* DBCacheRpcInsertAsk::release_primarykey() {
  clear_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primarykey_;
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcInsertAsk::set_allocated_primarykey(::std::string* primarykey) {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete primarykey_;
  }
  if (primarykey) {
    set_has_primarykey();
    primarykey_ = primarykey;
  } else {
    clear_has_primarykey();
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SubsidiaryKey = 3;
inline bool DBCacheRpcInsertAsk::has_subsidiarykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBCacheRpcInsertAsk::set_has_subsidiarykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBCacheRpcInsertAsk::clear_has_subsidiarykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBCacheRpcInsertAsk::clear_subsidiarykey() {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_->clear();
  }
  clear_has_subsidiarykey();
}
inline const ::std::string& DBCacheRpcInsertAsk::subsidiarykey() const {
  return *subsidiarykey_;
}
inline void DBCacheRpcInsertAsk::set_subsidiarykey(const ::std::string& value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_subsidiarykey(const char* value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_subsidiarykey(const char* value, size_t size) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcInsertAsk::mutable_subsidiarykey() {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  return subsidiarykey_;
}
inline ::std::string* DBCacheRpcInsertAsk::release_subsidiarykey() {
  clear_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subsidiarykey_;
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcInsertAsk::set_allocated_subsidiarykey(::std::string* subsidiarykey) {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete subsidiarykey_;
  }
  if (subsidiarykey) {
    set_has_subsidiarykey();
    subsidiarykey_ = subsidiarykey;
  } else {
    clear_has_subsidiarykey();
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PKValue = 4;
inline bool DBCacheRpcInsertAsk::has_pkvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBCacheRpcInsertAsk::set_has_pkvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBCacheRpcInsertAsk::clear_has_pkvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBCacheRpcInsertAsk::clear_pkvalue() {
  if (pkvalue_ != &::google::protobuf::internal::kEmptyString) {
    pkvalue_->clear();
  }
  clear_has_pkvalue();
}
inline const ::std::string& DBCacheRpcInsertAsk::pkvalue() const {
  return *pkvalue_;
}
inline void DBCacheRpcInsertAsk::set_pkvalue(const ::std::string& value) {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  pkvalue_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_pkvalue(const char* value) {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  pkvalue_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_pkvalue(const char* value, size_t size) {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  pkvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcInsertAsk::mutable_pkvalue() {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  return pkvalue_;
}
inline ::std::string* DBCacheRpcInsertAsk::release_pkvalue() {
  clear_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pkvalue_;
    pkvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcInsertAsk::set_allocated_pkvalue(::std::string* pkvalue) {
  if (pkvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete pkvalue_;
  }
  if (pkvalue) {
    set_has_pkvalue();
    pkvalue_ = pkvalue;
  } else {
    clear_has_pkvalue();
    pkvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SKValue = 6;
inline bool DBCacheRpcInsertAsk::has_skvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBCacheRpcInsertAsk::set_has_skvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBCacheRpcInsertAsk::clear_has_skvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBCacheRpcInsertAsk::clear_skvalue() {
  if (skvalue_ != &::google::protobuf::internal::kEmptyString) {
    skvalue_->clear();
  }
  clear_has_skvalue();
}
inline const ::std::string& DBCacheRpcInsertAsk::skvalue() const {
  return *skvalue_;
}
inline void DBCacheRpcInsertAsk::set_skvalue(const ::std::string& value) {
  set_has_skvalue();
  if (skvalue_ == &::google::protobuf::internal::kEmptyString) {
    skvalue_ = new ::std::string;
  }
  skvalue_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_skvalue(const char* value) {
  set_has_skvalue();
  if (skvalue_ == &::google::protobuf::internal::kEmptyString) {
    skvalue_ = new ::std::string;
  }
  skvalue_->assign(value);
}
inline void DBCacheRpcInsertAsk::set_skvalue(const char* value, size_t size) {
  set_has_skvalue();
  if (skvalue_ == &::google::protobuf::internal::kEmptyString) {
    skvalue_ = new ::std::string;
  }
  skvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcInsertAsk::mutable_skvalue() {
  set_has_skvalue();
  if (skvalue_ == &::google::protobuf::internal::kEmptyString) {
    skvalue_ = new ::std::string;
  }
  return skvalue_;
}
inline ::std::string* DBCacheRpcInsertAsk::release_skvalue() {
  clear_has_skvalue();
  if (skvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skvalue_;
    skvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcInsertAsk::set_allocated_skvalue(::std::string* skvalue) {
  if (skvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete skvalue_;
  }
  if (skvalue) {
    set_has_skvalue();
    skvalue_ = skvalue;
  } else {
    clear_has_skvalue();
    skvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DBCacheFV FVArray = 5;
inline int DBCacheRpcInsertAsk::fvarray_size() const {
  return fvarray_.size();
}
inline void DBCacheRpcInsertAsk::clear_fvarray() {
  fvarray_.Clear();
}
inline const ::DBCacheFV& DBCacheRpcInsertAsk::fvarray(int index) const {
  return fvarray_.Get(index);
}
inline ::DBCacheFV* DBCacheRpcInsertAsk::mutable_fvarray(int index) {
  return fvarray_.Mutable(index);
}
inline ::DBCacheFV* DBCacheRpcInsertAsk::add_fvarray() {
  return fvarray_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DBCacheFV >&
DBCacheRpcInsertAsk::fvarray() const {
  return fvarray_;
}
inline ::google::protobuf::RepeatedPtrField< ::DBCacheFV >*
DBCacheRpcInsertAsk::mutable_fvarray() {
  return &fvarray_;
}

// -------------------------------------------------------------------

// DBCacheRpcInsertReply

// optional sint32 Result = 1 [default = -9999];
inline bool DBCacheRpcInsertReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcInsertReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcInsertReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcInsertReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 DBCacheRpcInsertReply::result() const {
  return result_;
}
inline void DBCacheRpcInsertReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// DBCacheRpcDeleteAsk

// optional string TabName = 1;
inline bool DBCacheRpcDeleteAsk::has_tabname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcDeleteAsk::set_has_tabname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcDeleteAsk::clear_has_tabname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcDeleteAsk::clear_tabname() {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    tabname_->clear();
  }
  clear_has_tabname();
}
inline const ::std::string& DBCacheRpcDeleteAsk::tabname() const {
  return *tabname_;
}
inline void DBCacheRpcDeleteAsk::set_tabname(const ::std::string& value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_tabname(const char* value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_tabname(const char* value, size_t size) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcDeleteAsk::mutable_tabname() {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  return tabname_;
}
inline ::std::string* DBCacheRpcDeleteAsk::release_tabname() {
  clear_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tabname_;
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcDeleteAsk::set_allocated_tabname(::std::string* tabname) {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    delete tabname_;
  }
  if (tabname) {
    set_has_tabname();
    tabname_ = tabname;
  } else {
    clear_has_tabname();
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PrimaryKey = 2;
inline bool DBCacheRpcDeleteAsk::has_primarykey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheRpcDeleteAsk::set_has_primarykey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheRpcDeleteAsk::clear_has_primarykey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheRpcDeleteAsk::clear_primarykey() {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    primarykey_->clear();
  }
  clear_has_primarykey();
}
inline const ::std::string& DBCacheRpcDeleteAsk::primarykey() const {
  return *primarykey_;
}
inline void DBCacheRpcDeleteAsk::set_primarykey(const ::std::string& value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_primarykey(const char* value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_primarykey(const char* value, size_t size) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcDeleteAsk::mutable_primarykey() {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  return primarykey_;
}
inline ::std::string* DBCacheRpcDeleteAsk::release_primarykey() {
  clear_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primarykey_;
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcDeleteAsk::set_allocated_primarykey(::std::string* primarykey) {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete primarykey_;
  }
  if (primarykey) {
    set_has_primarykey();
    primarykey_ = primarykey;
  } else {
    clear_has_primarykey();
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SubsidiaryKey = 3;
inline bool DBCacheRpcDeleteAsk::has_subsidiarykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBCacheRpcDeleteAsk::set_has_subsidiarykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBCacheRpcDeleteAsk::clear_has_subsidiarykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBCacheRpcDeleteAsk::clear_subsidiarykey() {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_->clear();
  }
  clear_has_subsidiarykey();
}
inline const ::std::string& DBCacheRpcDeleteAsk::subsidiarykey() const {
  return *subsidiarykey_;
}
inline void DBCacheRpcDeleteAsk::set_subsidiarykey(const ::std::string& value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_subsidiarykey(const char* value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_subsidiarykey(const char* value, size_t size) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcDeleteAsk::mutable_subsidiarykey() {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  return subsidiarykey_;
}
inline ::std::string* DBCacheRpcDeleteAsk::release_subsidiarykey() {
  clear_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subsidiarykey_;
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcDeleteAsk::set_allocated_subsidiarykey(::std::string* subsidiarykey) {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete subsidiarykey_;
  }
  if (subsidiarykey) {
    set_has_subsidiarykey();
    subsidiarykey_ = subsidiarykey;
  } else {
    clear_has_subsidiarykey();
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 Type = 4 [default = 0];
inline bool DBCacheRpcDeleteAsk::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBCacheRpcDeleteAsk::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBCacheRpcDeleteAsk::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBCacheRpcDeleteAsk::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DBCacheRpcDeleteAsk::type() const {
  return type_;
}
inline void DBCacheRpcDeleteAsk::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string KeyValue = 5;
inline bool DBCacheRpcDeleteAsk::has_keyvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBCacheRpcDeleteAsk::set_has_keyvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBCacheRpcDeleteAsk::clear_has_keyvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBCacheRpcDeleteAsk::clear_keyvalue() {
  if (keyvalue_ != &::google::protobuf::internal::kEmptyString) {
    keyvalue_->clear();
  }
  clear_has_keyvalue();
}
inline const ::std::string& DBCacheRpcDeleteAsk::keyvalue() const {
  return *keyvalue_;
}
inline void DBCacheRpcDeleteAsk::set_keyvalue(const ::std::string& value) {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  keyvalue_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_keyvalue(const char* value) {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  keyvalue_->assign(value);
}
inline void DBCacheRpcDeleteAsk::set_keyvalue(const char* value, size_t size) {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  keyvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcDeleteAsk::mutable_keyvalue() {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  return keyvalue_;
}
inline ::std::string* DBCacheRpcDeleteAsk::release_keyvalue() {
  clear_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyvalue_;
    keyvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcDeleteAsk::set_allocated_keyvalue(::std::string* keyvalue) {
  if (keyvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete keyvalue_;
  }
  if (keyvalue) {
    set_has_keyvalue();
    keyvalue_ = keyvalue;
  } else {
    clear_has_keyvalue();
    keyvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBCacheRpcDeleteReply

// optional sint32 Result = 1 [default = -9999];
inline bool DBCacheRpcDeleteReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcDeleteReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcDeleteReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcDeleteReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 DBCacheRpcDeleteReply::result() const {
  return result_;
}
inline void DBCacheRpcDeleteReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional sint32 NrAffects = 2 [default = 0];
inline bool DBCacheRpcDeleteReply::has_nraffects() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheRpcDeleteReply::set_has_nraffects() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheRpcDeleteReply::clear_has_nraffects() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheRpcDeleteReply::clear_nraffects() {
  nraffects_ = 0;
  clear_has_nraffects();
}
inline ::google::protobuf::int32 DBCacheRpcDeleteReply::nraffects() const {
  return nraffects_;
}
inline void DBCacheRpcDeleteReply::set_nraffects(::google::protobuf::int32 value) {
  set_has_nraffects();
  nraffects_ = value;
}

// -------------------------------------------------------------------

// DBCacheRpcUpdateAsk

// optional string TabName = 1;
inline bool DBCacheRpcUpdateAsk::has_tabname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcUpdateAsk::set_has_tabname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcUpdateAsk::clear_has_tabname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcUpdateAsk::clear_tabname() {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    tabname_->clear();
  }
  clear_has_tabname();
}
inline const ::std::string& DBCacheRpcUpdateAsk::tabname() const {
  return *tabname_;
}
inline void DBCacheRpcUpdateAsk::set_tabname(const ::std::string& value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_tabname(const char* value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_tabname(const char* value, size_t size) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcUpdateAsk::mutable_tabname() {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  return tabname_;
}
inline ::std::string* DBCacheRpcUpdateAsk::release_tabname() {
  clear_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tabname_;
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcUpdateAsk::set_allocated_tabname(::std::string* tabname) {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    delete tabname_;
  }
  if (tabname) {
    set_has_tabname();
    tabname_ = tabname;
  } else {
    clear_has_tabname();
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PrimaryKey = 2;
inline bool DBCacheRpcUpdateAsk::has_primarykey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheRpcUpdateAsk::set_has_primarykey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheRpcUpdateAsk::clear_has_primarykey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheRpcUpdateAsk::clear_primarykey() {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    primarykey_->clear();
  }
  clear_has_primarykey();
}
inline const ::std::string& DBCacheRpcUpdateAsk::primarykey() const {
  return *primarykey_;
}
inline void DBCacheRpcUpdateAsk::set_primarykey(const ::std::string& value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_primarykey(const char* value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_primarykey(const char* value, size_t size) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcUpdateAsk::mutable_primarykey() {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  return primarykey_;
}
inline ::std::string* DBCacheRpcUpdateAsk::release_primarykey() {
  clear_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primarykey_;
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcUpdateAsk::set_allocated_primarykey(::std::string* primarykey) {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete primarykey_;
  }
  if (primarykey) {
    set_has_primarykey();
    primarykey_ = primarykey;
  } else {
    clear_has_primarykey();
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SubsidiaryKey = 6;
inline bool DBCacheRpcUpdateAsk::has_subsidiarykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBCacheRpcUpdateAsk::set_has_subsidiarykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBCacheRpcUpdateAsk::clear_has_subsidiarykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBCacheRpcUpdateAsk::clear_subsidiarykey() {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_->clear();
  }
  clear_has_subsidiarykey();
}
inline const ::std::string& DBCacheRpcUpdateAsk::subsidiarykey() const {
  return *subsidiarykey_;
}
inline void DBCacheRpcUpdateAsk::set_subsidiarykey(const ::std::string& value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_subsidiarykey(const char* value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_subsidiarykey(const char* value, size_t size) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcUpdateAsk::mutable_subsidiarykey() {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  return subsidiarykey_;
}
inline ::std::string* DBCacheRpcUpdateAsk::release_subsidiarykey() {
  clear_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subsidiarykey_;
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcUpdateAsk::set_allocated_subsidiarykey(::std::string* subsidiarykey) {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete subsidiarykey_;
  }
  if (subsidiarykey) {
    set_has_subsidiarykey();
    subsidiarykey_ = subsidiarykey;
  } else {
    clear_has_subsidiarykey();
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PKValue = 4;
inline bool DBCacheRpcUpdateAsk::has_pkvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBCacheRpcUpdateAsk::set_has_pkvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBCacheRpcUpdateAsk::clear_has_pkvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBCacheRpcUpdateAsk::clear_pkvalue() {
  if (pkvalue_ != &::google::protobuf::internal::kEmptyString) {
    pkvalue_->clear();
  }
  clear_has_pkvalue();
}
inline const ::std::string& DBCacheRpcUpdateAsk::pkvalue() const {
  return *pkvalue_;
}
inline void DBCacheRpcUpdateAsk::set_pkvalue(const ::std::string& value) {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  pkvalue_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_pkvalue(const char* value) {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  pkvalue_->assign(value);
}
inline void DBCacheRpcUpdateAsk::set_pkvalue(const char* value, size_t size) {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  pkvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcUpdateAsk::mutable_pkvalue() {
  set_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    pkvalue_ = new ::std::string;
  }
  return pkvalue_;
}
inline ::std::string* DBCacheRpcUpdateAsk::release_pkvalue() {
  clear_has_pkvalue();
  if (pkvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pkvalue_;
    pkvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcUpdateAsk::set_allocated_pkvalue(::std::string* pkvalue) {
  if (pkvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete pkvalue_;
  }
  if (pkvalue) {
    set_has_pkvalue();
    pkvalue_ = pkvalue;
  } else {
    clear_has_pkvalue();
    pkvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .DBCacheFV FVArray = 5;
inline int DBCacheRpcUpdateAsk::fvarray_size() const {
  return fvarray_.size();
}
inline void DBCacheRpcUpdateAsk::clear_fvarray() {
  fvarray_.Clear();
}
inline const ::DBCacheFV& DBCacheRpcUpdateAsk::fvarray(int index) const {
  return fvarray_.Get(index);
}
inline ::DBCacheFV* DBCacheRpcUpdateAsk::mutable_fvarray(int index) {
  return fvarray_.Mutable(index);
}
inline ::DBCacheFV* DBCacheRpcUpdateAsk::add_fvarray() {
  return fvarray_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DBCacheFV >&
DBCacheRpcUpdateAsk::fvarray() const {
  return fvarray_;
}
inline ::google::protobuf::RepeatedPtrField< ::DBCacheFV >*
DBCacheRpcUpdateAsk::mutable_fvarray() {
  return &fvarray_;
}

// -------------------------------------------------------------------

// DBCacheRpcUpdateReply

// optional sint32 Result = 1 [default = -9999];
inline bool DBCacheRpcUpdateReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcUpdateReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcUpdateReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcUpdateReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 DBCacheRpcUpdateReply::result() const {
  return result_;
}
inline void DBCacheRpcUpdateReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// DBCacheRpcSelectAsk

// optional string TabName = 1;
inline bool DBCacheRpcSelectAsk::has_tabname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcSelectAsk::set_has_tabname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcSelectAsk::clear_has_tabname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcSelectAsk::clear_tabname() {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    tabname_->clear();
  }
  clear_has_tabname();
}
inline const ::std::string& DBCacheRpcSelectAsk::tabname() const {
  return *tabname_;
}
inline void DBCacheRpcSelectAsk::set_tabname(const ::std::string& value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_tabname(const char* value) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_tabname(const char* value, size_t size) {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  tabname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcSelectAsk::mutable_tabname() {
  set_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    tabname_ = new ::std::string;
  }
  return tabname_;
}
inline ::std::string* DBCacheRpcSelectAsk::release_tabname() {
  clear_has_tabname();
  if (tabname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tabname_;
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcSelectAsk::set_allocated_tabname(::std::string* tabname) {
  if (tabname_ != &::google::protobuf::internal::kEmptyString) {
    delete tabname_;
  }
  if (tabname) {
    set_has_tabname();
    tabname_ = tabname;
  } else {
    clear_has_tabname();
    tabname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string PrimaryKey = 2;
inline bool DBCacheRpcSelectAsk::has_primarykey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheRpcSelectAsk::set_has_primarykey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheRpcSelectAsk::clear_has_primarykey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheRpcSelectAsk::clear_primarykey() {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    primarykey_->clear();
  }
  clear_has_primarykey();
}
inline const ::std::string& DBCacheRpcSelectAsk::primarykey() const {
  return *primarykey_;
}
inline void DBCacheRpcSelectAsk::set_primarykey(const ::std::string& value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_primarykey(const char* value) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_primarykey(const char* value, size_t size) {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  primarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcSelectAsk::mutable_primarykey() {
  set_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    primarykey_ = new ::std::string;
  }
  return primarykey_;
}
inline ::std::string* DBCacheRpcSelectAsk::release_primarykey() {
  clear_has_primarykey();
  if (primarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = primarykey_;
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcSelectAsk::set_allocated_primarykey(::std::string* primarykey) {
  if (primarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete primarykey_;
  }
  if (primarykey) {
    set_has_primarykey();
    primarykey_ = primarykey;
  } else {
    clear_has_primarykey();
    primarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SubsidiaryKey = 3;
inline bool DBCacheRpcSelectAsk::has_subsidiarykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBCacheRpcSelectAsk::set_has_subsidiarykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBCacheRpcSelectAsk::clear_has_subsidiarykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBCacheRpcSelectAsk::clear_subsidiarykey() {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_->clear();
  }
  clear_has_subsidiarykey();
}
inline const ::std::string& DBCacheRpcSelectAsk::subsidiarykey() const {
  return *subsidiarykey_;
}
inline void DBCacheRpcSelectAsk::set_subsidiarykey(const ::std::string& value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_subsidiarykey(const char* value) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_subsidiarykey(const char* value, size_t size) {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  subsidiarykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcSelectAsk::mutable_subsidiarykey() {
  set_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    subsidiarykey_ = new ::std::string;
  }
  return subsidiarykey_;
}
inline ::std::string* DBCacheRpcSelectAsk::release_subsidiarykey() {
  clear_has_subsidiarykey();
  if (subsidiarykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subsidiarykey_;
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcSelectAsk::set_allocated_subsidiarykey(::std::string* subsidiarykey) {
  if (subsidiarykey_ != &::google::protobuf::internal::kEmptyString) {
    delete subsidiarykey_;
  }
  if (subsidiarykey) {
    set_has_subsidiarykey();
    subsidiarykey_ = subsidiarykey;
  } else {
    clear_has_subsidiarykey();
    subsidiarykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 Type = 4 [default = 0];
inline bool DBCacheRpcSelectAsk::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBCacheRpcSelectAsk::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBCacheRpcSelectAsk::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBCacheRpcSelectAsk::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DBCacheRpcSelectAsk::type() const {
  return type_;
}
inline void DBCacheRpcSelectAsk::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string KeyValue = 5;
inline bool DBCacheRpcSelectAsk::has_keyvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBCacheRpcSelectAsk::set_has_keyvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBCacheRpcSelectAsk::clear_has_keyvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBCacheRpcSelectAsk::clear_keyvalue() {
  if (keyvalue_ != &::google::protobuf::internal::kEmptyString) {
    keyvalue_->clear();
  }
  clear_has_keyvalue();
}
inline const ::std::string& DBCacheRpcSelectAsk::keyvalue() const {
  return *keyvalue_;
}
inline void DBCacheRpcSelectAsk::set_keyvalue(const ::std::string& value) {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  keyvalue_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_keyvalue(const char* value) {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  keyvalue_->assign(value);
}
inline void DBCacheRpcSelectAsk::set_keyvalue(const char* value, size_t size) {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  keyvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcSelectAsk::mutable_keyvalue() {
  set_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    keyvalue_ = new ::std::string;
  }
  return keyvalue_;
}
inline ::std::string* DBCacheRpcSelectAsk::release_keyvalue() {
  clear_has_keyvalue();
  if (keyvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyvalue_;
    keyvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheRpcSelectAsk::set_allocated_keyvalue(::std::string* keyvalue) {
  if (keyvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete keyvalue_;
  }
  if (keyvalue) {
    set_has_keyvalue();
    keyvalue_ = keyvalue;
  } else {
    clear_has_keyvalue();
    keyvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string Fields = 6;
inline int DBCacheRpcSelectAsk::fields_size() const {
  return fields_.size();
}
inline void DBCacheRpcSelectAsk::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& DBCacheRpcSelectAsk::fields(int index) const {
  return fields_.Get(index);
}
inline ::std::string* DBCacheRpcSelectAsk::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline void DBCacheRpcSelectAsk::set_fields(int index, const ::std::string& value) {
  fields_.Mutable(index)->assign(value);
}
inline void DBCacheRpcSelectAsk::set_fields(int index, const char* value) {
  fields_.Mutable(index)->assign(value);
}
inline void DBCacheRpcSelectAsk::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcSelectAsk::add_fields() {
  return fields_.Add();
}
inline void DBCacheRpcSelectAsk::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
}
inline void DBCacheRpcSelectAsk::add_fields(const char* value) {
  fields_.Add()->assign(value);
}
inline void DBCacheRpcSelectAsk::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DBCacheRpcSelectAsk::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DBCacheRpcSelectAsk::mutable_fields() {
  return &fields_;
}

// -------------------------------------------------------------------

// DBCacheRpcSelectReply

// optional sint32 Result = 1 [default = -9999];
inline bool DBCacheRpcSelectReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheRpcSelectReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheRpcSelectReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheRpcSelectReply::clear_result() {
  result_ = -9999;
  clear_has_result();
}
inline ::google::protobuf::int32 DBCacheRpcSelectReply::result() const {
  return result_;
}
inline void DBCacheRpcSelectReply::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional sint32 NrAffects = 2 [default = 0];
inline bool DBCacheRpcSelectReply::has_nraffects() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheRpcSelectReply::set_has_nraffects() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheRpcSelectReply::clear_has_nraffects() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheRpcSelectReply::clear_nraffects() {
  nraffects_ = 0;
  clear_has_nraffects();
}
inline ::google::protobuf::int32 DBCacheRpcSelectReply::nraffects() const {
  return nraffects_;
}
inline void DBCacheRpcSelectReply::set_nraffects(::google::protobuf::int32 value) {
  set_has_nraffects();
  nraffects_ = value;
}

// repeated string Fields = 3;
inline int DBCacheRpcSelectReply::fields_size() const {
  return fields_.size();
}
inline void DBCacheRpcSelectReply::clear_fields() {
  fields_.Clear();
}
inline const ::std::string& DBCacheRpcSelectReply::fields(int index) const {
  return fields_.Get(index);
}
inline ::std::string* DBCacheRpcSelectReply::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline void DBCacheRpcSelectReply::set_fields(int index, const ::std::string& value) {
  fields_.Mutable(index)->assign(value);
}
inline void DBCacheRpcSelectReply::set_fields(int index, const char* value) {
  fields_.Mutable(index)->assign(value);
}
inline void DBCacheRpcSelectReply::set_fields(int index, const char* value, size_t size) {
  fields_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRpcSelectReply::add_fields() {
  return fields_.Add();
}
inline void DBCacheRpcSelectReply::add_fields(const ::std::string& value) {
  fields_.Add()->assign(value);
}
inline void DBCacheRpcSelectReply::add_fields(const char* value) {
  fields_.Add()->assign(value);
}
inline void DBCacheRpcSelectReply::add_fields(const char* value, size_t size) {
  fields_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DBCacheRpcSelectReply::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DBCacheRpcSelectReply::mutable_fields() {
  return &fields_;
}

// repeated .DBCacheRecordLine Records = 4;
inline int DBCacheRpcSelectReply::records_size() const {
  return records_.size();
}
inline void DBCacheRpcSelectReply::clear_records() {
  records_.Clear();
}
inline const ::DBCacheRecordLine& DBCacheRpcSelectReply::records(int index) const {
  return records_.Get(index);
}
inline ::DBCacheRecordLine* DBCacheRpcSelectReply::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::DBCacheRecordLine* DBCacheRpcSelectReply::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DBCacheRecordLine >&
DBCacheRpcSelectReply::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::DBCacheRecordLine >*
DBCacheRpcSelectReply::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// DBCacheFV

// optional string Field = 1;
inline bool DBCacheFV::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBCacheFV::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBCacheFV::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBCacheFV::clear_field() {
  if (field_ != &::google::protobuf::internal::kEmptyString) {
    field_->clear();
  }
  clear_has_field();
}
inline const ::std::string& DBCacheFV::field() const {
  return *field_;
}
inline void DBCacheFV::set_field(const ::std::string& value) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void DBCacheFV::set_field(const char* value) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(value);
}
inline void DBCacheFV::set_field(const char* value, size_t size) {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  field_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheFV::mutable_field() {
  set_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    field_ = new ::std::string;
  }
  return field_;
}
inline ::std::string* DBCacheFV::release_field() {
  clear_has_field();
  if (field_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = field_;
    field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheFV::set_allocated_field(::std::string* field) {
  if (field_ != &::google::protobuf::internal::kEmptyString) {
    delete field_;
  }
  if (field) {
    set_has_field();
    field_ = field;
  } else {
    clear_has_field();
    field_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Value = 2;
inline bool DBCacheFV::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBCacheFV::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBCacheFV::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBCacheFV::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DBCacheFV::value() const {
  return *value_;
}
inline void DBCacheFV::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DBCacheFV::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void DBCacheFV::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheFV::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* DBCacheFV::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBCacheFV::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBCacheRecordLine

// repeated string Values = 2;
inline int DBCacheRecordLine::values_size() const {
  return values_.size();
}
inline void DBCacheRecordLine::clear_values() {
  values_.Clear();
}
inline const ::std::string& DBCacheRecordLine::values(int index) const {
  return values_.Get(index);
}
inline ::std::string* DBCacheRecordLine::mutable_values(int index) {
  return values_.Mutable(index);
}
inline void DBCacheRecordLine::set_values(int index, const ::std::string& value) {
  values_.Mutable(index)->assign(value);
}
inline void DBCacheRecordLine::set_values(int index, const char* value) {
  values_.Mutable(index)->assign(value);
}
inline void DBCacheRecordLine::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBCacheRecordLine::add_values() {
  return values_.Add();
}
inline void DBCacheRecordLine::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
}
inline void DBCacheRecordLine::add_values(const char* value) {
  values_.Add()->assign(value);
}
inline void DBCacheRecordLine::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DBCacheRecordLine::values() const {
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DBCacheRecordLine::mutable_values() {
  return &values_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_DBCacheSvrRpc_2eproto__INCLUDED
